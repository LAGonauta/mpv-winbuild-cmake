From b20c3b546e648473bf46e17f5b10bd821411e318 Mon Sep 17 00:00:00 2001
From: shinchiro <shinchiro@users.noreply.github.com>
Date: Sat, 25 Nov 2017 14:21:58 +0800
Subject: [PATCH] Msys2 patches for python3

Taken from:
https://github.com/Alexpux/MINGW-packages/tree/65d2264f4/mingw-w64-python3
---
 Include/bytesobject.h                      |   4 +-
 Include/iscygpty.h                         |  41 +++
 Include/osdefs.h                           |   3 +-
 Include/pgenheaders.h                      |   4 +-
 Include/py_curses.h                        |   9 +
 Include/pyerrors.h                         |   4 +-
 Include/pylifecycle.h                      |   8 +-
 Include/pyport.h                           |  47 ++-
 Include/sysmodule.h                        |   4 +-
 Lib/compileall.py                          |   2 +
 Lib/ctypes/__init__.py                     |   4 +-
 Lib/distutils/ccompiler.py                 |   4 +-
 Lib/distutils/command/build_ext.py         |  21 +-
 Lib/distutils/command/install.py           |  15 +-
 Lib/distutils/cygwinccompiler.py           |  36 ++-
 Lib/distutils/spawn.py                     |  15 +-
 Lib/distutils/sysconfig.py                 |  43 ++-
 Lib/distutils/unixccompiler.py             |   8 +-
 Lib/distutils/util.py                      |  28 +-
 Lib/ntpath.py                              |  77 ++---
 Lib/site.py                                |   9 +-
 Lib/ssl.py                                 |   4 +-
 Lib/sysconfig.py                           |  67 +++--
 Makefile.pre.in                            |  61 +++-
 Misc/config_mingw                          |  15 +
 Misc/cross_mingw32                         |  11 +
 Misc/python-config.sh.in                   |  67 +++--
 Modules/Setup.config.in                    |  11 +
 Modules/Setup.dist                         |  11 +-
 Modules/_ctypes/_ctypes.c                  |  17 ++
 Modules/_ctypes/callproc.c                 |  21 ++
 Modules/_ctypes/libffi/fficonfig.py.in     |   4 +
 Modules/_cursesmodule.c                    |  31 ++
 Modules/_gdbmmodule.c                      |   2 +-
 Modules/_io/_iomodule.c                    |   2 +-
 Modules/_io/fileio.c                       |   3 +-
 Modules/_localemodule.c                    |   7 +
 Modules/_multiprocessing/multiprocessing.c |   2 +-
 Modules/_winapi.c                          |   2 +
 Modules/getpath.c                          | 154 +++++++++-
 Modules/makesetup                          |   2 +-
 Modules/parsermodule.c                     |   2 +-
 Modules/posixmodule.c                      |  82 ++++-
 Modules/readline.c                         |   6 +
 Modules/selectmodule.c                     |   6 +-
 Modules/socketmodule.c                     |   6 +
 Modules/socketmodule.h                     |   2 +-
 PC/getpathp.c                              | 227 ++++++++++++++
 PC/msvcrtmodule.c                          |   2 +
 PC/winreg.c                                |  19 ++
 Parser/metagrammar.c                       |   4 +-
 Programs/_freeze_importlib.c               |   2 +-
 Programs/python.c                          |   2 +-
 Python/condvar.h                           |   6 +
 Python/dynload_win.c                       |  10 +
 Python/fileblocks.c                        |  17 ++
 Python/frozenmain.c                        |   3 +-
 Python/getcompiler.c                       |  17 +-
 Python/getplatform.c                       |   6 +
 Python/iscygpty.c                          | 185 ++++++++++++
 Python/pylifecycle.c                       | 117 +++++++-
 Python/pytime.c                            |  31 +-
 Python/sysmodule.c                         |   6 +-
 Python/thread.c                            |   6 +
 Python/traceback.c                         |   2 +-
 configure.ac                               | 461 ++++++++++++++++++++++++++++-
 pyconfig.h.in                              |  16 +-
 setup.py                                   | 178 ++++++++---
 68 files changed, 2020 insertions(+), 281 deletions(-)
 create mode 100644 Include/iscygpty.h
 create mode 100644 Misc/config_mingw
 create mode 100644 Misc/cross_mingw32
 create mode 100644 Python/fileblocks.c
 create mode 100644 Python/iscygpty.c

diff --git a/Include/bytesobject.h b/Include/bytesobject.h
index 0f0bf9f..f1e3c18 100644
--- a/Include/bytesobject.h
+++ b/Include/bytesobject.h
@@ -52,9 +52,9 @@ PyAPI_FUNC(PyObject *) PyBytes_FromStringAndSize(const char *, Py_ssize_t);
 PyAPI_FUNC(PyObject *) PyBytes_FromString(const char *);
 PyAPI_FUNC(PyObject *) PyBytes_FromObject(PyObject *);
 PyAPI_FUNC(PyObject *) PyBytes_FromFormatV(const char*, va_list)
-				Py_GCC_ATTRIBUTE((format(printf, 1, 0)));
+				Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 0)));
 PyAPI_FUNC(PyObject *) PyBytes_FromFormat(const char*, ...)
-				Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+				Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 2)));
 PyAPI_FUNC(Py_ssize_t) PyBytes_Size(PyObject *);
 PyAPI_FUNC(char *) PyBytes_AsString(PyObject *);
 PyAPI_FUNC(PyObject *) PyBytes_Repr(PyObject *, int);
diff --git a/Include/iscygpty.h b/Include/iscygpty.h
new file mode 100644
index 0000000..82fd0af
--- /dev/null
+++ b/Include/iscygpty.h
@@ -0,0 +1,41 @@
+/*
+ * iscygpty.h -- part of ptycheck
+ * https://github.com/k-takata/ptycheck
+ *
+ * Copyright (c) 2015-2017 K.Takata
+ *
+ * You can redistribute it and/or modify it under the terms of either
+ * the MIT license (as described below) or the Vim license.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _ISCYGPTY_H
+#define _ISCYGPTY_H
+
+#ifdef _WIN32
+int is_cygpty(int fd);
+int is_cygpty_used(void);
+#else
+#define is_cygpty(fd)		0
+#define is_cygpty_used()	0
+#endif
+
+#endif /* _ISCYGPTY_H */
diff --git a/Include/osdefs.h b/Include/osdefs.h
index bd84c1c..03def29 100644
--- a/Include/osdefs.h
+++ b/Include/osdefs.h
@@ -10,8 +10,8 @@ extern "C" {
 #ifdef MS_WINDOWS
 #define SEP L'\\'
 #define ALTSEP L'/'
-#define MAXPATHLEN 256
 #define DELIM L';'
+#define DELIMSTR L";"
 #endif
 
 /* Filename separator */
@@ -39,6 +39,7 @@ extern "C" {
 /* Search path entry delimiter */
 #ifndef DELIM
 #define DELIM L':'
+#define DELIMSTR L":"
 #endif
 
 #ifdef __cplusplus
diff --git a/Include/pgenheaders.h b/Include/pgenheaders.h
index 4843de6..023d91a 100644
--- a/Include/pgenheaders.h
+++ b/Include/pgenheaders.h
@@ -10,9 +10,9 @@ extern "C" {
 #include "Python.h"
 
 PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
-			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+			Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 2)));
 PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
-			Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+			Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 2)));
 
 #define addarc _Py_addarc
 #define addbit _Py_addbit
diff --git a/Include/py_curses.h b/Include/py_curses.h
index 3c21697..144714e 100644
--- a/Include/py_curses.h
+++ b/Include/py_curses.h
@@ -14,7 +14,9 @@
 /* the following define is necessary for OS X 10.6; without it, the
    Apple-supplied ncurses.h sets NCURSES_OPAQUE to 1, and then Python
    can't get at the WINDOW flags field. */
+/* NOTE configure check if ncurses require such definition
 #define NCURSES_OPAQUE 0
+*/
 #endif /* __APPLE__ */
 
 #ifdef __FreeBSD__
@@ -54,12 +56,19 @@
 #endif
 #endif
 
+#if defined(__MINGW32__) && !defined(_ISPAD)
+#define _ISPAD 0x10
+#endif
+
 #ifdef HAVE_NCURSES_H
 /* configure was checking <curses.h>, but we will
    use <ncurses.h>, which has all these features. */
+/* NOTE configure check for existence of flags
+ * Also flags are visible only if WINDOW structure is not opaque
 #ifndef WINDOW_HAS_FLAGS
 #define WINDOW_HAS_FLAGS 1
 #endif
+*/
 #ifndef MVWDELCH_IS_EXPRESSION
 #define MVWDELCH_IS_EXPRESSION 1
 #endif
diff --git a/Include/pyerrors.h b/Include/pyerrors.h
index 8c1dbc5..506fcd0 100644
--- a/Include/pyerrors.h
+++ b/Include/pyerrors.h
@@ -495,9 +495,9 @@ PyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(
 
 #include <stdarg.h>
 PyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)
-                        Py_GCC_ATTRIBUTE((format(printf, 3, 4)));
+                        Py_GCC_ATTRIBUTE((format(gnu_printf, 3, 4)));
 PyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
-                        Py_GCC_ATTRIBUTE((format(printf, 3, 0)));
+                        Py_GCC_ATTRIBUTE((format(gnu_printf, 3, 0)));
 
 #ifdef __cplusplus
 }
diff --git a/Include/pylifecycle.h b/Include/pylifecycle.h
index 01abfa9..046eca7 100644
--- a/Include/pylifecycle.h
+++ b/Include/pylifecycle.h
@@ -7,6 +7,12 @@
 extern "C" {
 #endif
 
+PyAPI_FUNC(wchar_t) Py_GetSepW(wchar_t *);
+PyAPI_FUNC(char) Py_GetSepA(char *);
+
+PyAPI_FUNC(void) Py_NormalizeSepsW(wchar_t *);
+PyAPI_FUNC(void) Py_NormalizeSepsA(char *);
+
 PyAPI_FUNC(void) Py_SetProgramName(wchar_t *);
 PyAPI_FUNC(wchar_t *) Py_GetProgramName(void);
 
@@ -60,7 +66,7 @@ PyAPI_FUNC(wchar_t *) Py_GetExecPrefix(void);
 PyAPI_FUNC(wchar_t *) Py_GetPath(void);
 PyAPI_FUNC(void)      Py_SetPath(const wchar_t *);
 #ifdef MS_WINDOWS
-int _Py_CheckPython3();
+int _Py_CheckPython3(void);
 #endif
 
 /* In their own files */
diff --git a/Include/pyport.h b/Include/pyport.h
index 426822a..1dbc3db 100644
--- a/Include/pyport.h
+++ b/Include/pyport.h
@@ -5,6 +5,21 @@
 
 #include <inttypes.h>
 
+#ifdef __MINGW32__
+/* Translate GCC[mingw*] platform specific defines to those
+ * used in python code.
+ */
+#if !defined(MS_WIN64) && defined(_WIN64)
+#  define MS_WIN64
+#endif
+#if !defined(MS_WIN32) && defined(_WIN32)
+#  define MS_WIN32
+#endif
+#if !defined(MS_WINDOWS) && defined(MS_WIN32)
+#  define MS_WINDOWS
+#endif
+#endif /*def __MINGW32__*/
+
 /**************************************************************************
 Symbols and macros to supply platform-independent interfaces to basic
 C language & library operations whose spellings vary across platforms.
@@ -141,6 +156,8 @@ typedef int Py_ssize_clean_t;
 #       define PY_FORMAT_SIZE_T "l"
 #   elif defined(MS_WINDOWS)
 #       define PY_FORMAT_SIZE_T "I"
+#   elif defined(__MINGW32__) && defined(__USE_MINGW_ANSI_STDIO)
+#       define PY_FORMAT_SIZE_T "z"
 #   else
 #       error "This platform's pyconfig.h needs to define PY_FORMAT_SIZE_T"
 #   endif
@@ -596,37 +613,39 @@ extern pid_t forkpty(int *, char *, struct termios *, struct winsize *);
 */
 
 /*
-  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+  Only MSVC windows ports is handled in PC/pyconfig.h.
 
-  Cygwin is the only other autoconf platform requiring special
+  Cygwin and Mingw are autoconf platforms requiring special
   linkage handling and it uses __declspec().
 */
-#if defined(__CYGWIN__)
+#if defined(__CYGWIN__) || defined(__MINGW32__)
 #       define HAVE_DECLSPEC_DLL
 #endif
 
 /* only get special linkage if built as shared or platform is Cygwin */
 #if defined(Py_ENABLE_SHARED) || defined(__CYGWIN__)
 #       if defined(HAVE_DECLSPEC_DLL)
-#               ifdef Py_BUILD_CORE
+#               if defined(Py_BUILD_CORE) || defined(Py_BUILD_CORE_MODULE)
 #                       define PyAPI_FUNC(RTYPE) __declspec(dllexport) RTYPE
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllexport) RTYPE
         /* module init functions inside the core need no external linkage */
-        /* except for Cygwin to handle embedding */
-#                       if defined(__CYGWIN__)
+        /* except for Cygwin/Mingw to handle embedding */
+#                       if defined(__CYGWIN__) || defined(__MINGW32__)
 #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
-#                       else /* __CYGWIN__ */
+#                       else
 #                               define PyMODINIT_FUNC PyObject*
-#                       endif /* __CYGWIN__ */
-#               else /* Py_BUILD_CORE */
+#                       endif
+#               else /* Py_BUILD_CORE... */
         /* Building an extension module, or an embedded situation */
         /* public Python functions and data are imported */
-        /* Under Cygwin, auto-import functions to prevent compilation */
+        /* Under Cygwin/Mingw, auto-import functions to prevent compilation */
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
-#                       if !defined(__CYGWIN__)
+#                       if defined(__CYGWIN__) || defined(__MINGW32__)
+#                               define PyAPI_FUNC(RTYPE) RTYPE
+#                       else
 #                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
-#                       endif /* !__CYGWIN__ */
+#                       endif
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
@@ -634,7 +653,7 @@ extern pid_t forkpty(int *, char *, struct termios *, struct winsize *);
 #                       else /* __cplusplus */
 #                               define PyMODINIT_FUNC __declspec(dllexport) PyObject*
 #                       endif /* __cplusplus */
-#               endif /* Py_BUILD_CORE */
+#               endif /* Py_BUILD_CORE... */
 #       endif /* HAVE_DECLSPEC */
 #endif /* Py_ENABLE_SHARED */
 
@@ -740,7 +759,7 @@ extern pid_t forkpty(int *, char *, struct termios *, struct winsize *);
 #define PY_LITTLE_ENDIAN 1
 #endif
 
-#ifdef Py_BUILD_CORE
+#if defined Py_BUILD_CORE || defined Py_BUILD_CORE_MODULE
 /*
  * Macros to protect CRT calls against instant termination when passed an
  * invalid parameter (issue23524).
diff --git a/Include/sysmodule.h b/Include/sysmodule.h
index c5547ff..8ff16f4 100644
--- a/Include/sysmodule.h
+++ b/Include/sysmodule.h
@@ -19,9 +19,9 @@ PyAPI_FUNC(void) PySys_SetArgvEx(int, wchar_t **, int);
 PyAPI_FUNC(void) PySys_SetPath(const wchar_t *);
 
 PyAPI_FUNC(void) PySys_WriteStdout(const char *format, ...)
-                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+                 Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 2)));
 PyAPI_FUNC(void) PySys_WriteStderr(const char *format, ...)
-                 Py_GCC_ATTRIBUTE((format(printf, 1, 2)));
+                 Py_GCC_ATTRIBUTE((format(gnu_printf, 1, 2)));
 PyAPI_FUNC(void) PySys_FormatStdout(const char *format, ...);
 PyAPI_FUNC(void) PySys_FormatStderr(const char *format, ...);
 
diff --git a/Lib/compileall.py b/Lib/compileall.py
index 1c9ceb6..435dd83 100644
--- a/Lib/compileall.py
+++ b/Lib/compileall.py
@@ -40,6 +40,8 @@ def _walk_dir(dir, ddir=None, maxlevels=10, quiet=0):
         if name == '__pycache__':
             continue
         fullname = os.path.join(dir, name)
+        if sys.platform == "win32" and sys.version.find("GCC") >= 0:
+            fullname = fullname.replace('\\','/')
         if ddir is not None:
             dfile = os.path.join(ddir, name)
         else:
diff --git a/Lib/ctypes/__init__.py b/Lib/ctypes/__init__.py
index f870968..8f359f5 100644
--- a/Lib/ctypes/__init__.py
+++ b/Lib/ctypes/__init__.py
@@ -428,7 +428,9 @@ class LibraryLoader(object):
 cdll = LibraryLoader(CDLL)
 pydll = LibraryLoader(PyDLL)
 
-if _os.name == "nt":
+if _os.name == "nt" and _sys.version.find('GCC') >= 0:
+    pythonapi = PyDLL("libpython%d.%d%s.dll" % (_sys.version_info[:2] + (_sys.abiflags,)), None)
+elif _os.name == "nt":
     pythonapi = PyDLL("python dll", None, _sys.dllhandle)
 elif _sys.platform == "cygwin":
     pythonapi = PyDLL("libpython%d.%d.dll" % _sys.version_info[:2])
diff --git a/Lib/distutils/ccompiler.py b/Lib/distutils/ccompiler.py
index b71d1d3..0b63f85 100644
--- a/Lib/distutils/ccompiler.py
+++ b/Lib/distutils/ccompiler.py
@@ -9,7 +9,7 @@ from distutils.spawn import spawn
 from distutils.file_util import move_file
 from distutils.dir_util import mkpath
 from distutils.dep_util import newer_pairwise, newer_group
-from distutils.util import split_quoted, execute
+from distutils.util import split_quoted, execute, get_platform
 from distutils import log
 
 class CCompiler:
@@ -947,6 +947,8 @@ def get_default_compiler(osname=None, platform=None):
         osname = os.name
     if platform is None:
         platform = sys.platform
+    if get_platform().startswith('mingw'):
+        return 'mingw32'
     for pattern, compiler in _default_compilers:
         if re.match(pattern, platform) is not None or \
            re.match(pattern, osname) is not None:
diff --git a/Lib/distutils/command/build_ext.py b/Lib/distutils/command/build_ext.py
index 74de782..2f58fd1 100644
--- a/Lib/distutils/command/build_ext.py
+++ b/Lib/distutils/command/build_ext.py
@@ -185,7 +185,7 @@ class build_ext(Command):
         # for extensions under windows use different directories
         # for Release and Debug builds.
         # also Python's library directory must be appended to library_dirs
-        if os.name == 'nt':
+        if os.name == 'nt' and not self.plat_name.startswith(('mingw')):
             # the 'libs' directory is for binary installs - we assume that
             # must be the *native* platform.  But we don't really support
             # cross-compiling via a binary install anyway, so we let it go.
@@ -217,12 +217,13 @@ class build_ext(Command):
 
         # for extensions under Cygwin and AtheOS Python's library directory must be
         # appended to library_dirs
-        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
+        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos' or self.plat_name.startswith(('mingw')):
             if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                 # building third party extensions
+                config_dir_name = os.path.basename(sysconfig.get_config_var('LIBPL'))
                 self.library_dirs.append(os.path.join(sys.prefix, "lib",
                                                       "python" + get_python_version(),
-                                                      "config"))
+                                                      config_dir_name))
             else:
                 # building python standard extensions
                 self.library_dirs.append('.')
@@ -702,6 +703,20 @@ class build_ext(Command):
         # pyconfig.h that MSVC groks.  The other Windows compilers all seem
         # to need it mentioned explicitly, though, so that's what we do.
         # Append '_d' to the python import library on debug builds.
+
+        # Use self.plat_name as it works even in case of
+        # cross-compilation (at least for mingw build).
+        if self.plat_name.startswith('mingw'):
+            from distutils import sysconfig
+            extra = []
+            for lib in (
+                sysconfig.get_config_var('BLDLIBRARY').split()
+                + sysconfig.get_config_var('SHLIBS').split()
+                ):
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            return ext.libraries + extra
+
         if sys.platform == "win32":
             from distutils._msvccompiler import MSVCCompiler
             if not isinstance(self.compiler, MSVCCompiler):
diff --git a/Lib/distutils/command/install.py b/Lib/distutils/command/install.py
index 0258d3d..c4afa75 100644
--- a/Lib/distutils/command/install.py
+++ b/Lib/distutils/command/install.py
@@ -20,10 +20,10 @@ from site import USER_SITE
 HAS_USER_SITE = True
 
 WINDOWS_SCHEME = {
-    'purelib': '$base/Lib/site-packages',
-    'platlib': '$base/Lib/site-packages',
-    'headers': '$base/Include/$dist_name',
-    'scripts': '$base/Scripts',
+    'purelib': '$base/lib/python$py_version_short/site-packages',
+    'platlib': '$base/lib/python$py_version_short/site-packages',
+    'headers': '$base/include/python$py_version_short$abiflags/$dist_name',
+    'scripts': '$base/bin',
     'data'   : '$base',
 }
 
@@ -50,8 +50,8 @@ if HAS_USER_SITE:
     INSTALL_SCHEMES['nt_user'] = {
         'purelib': '$usersite',
         'platlib': '$usersite',
-        'headers': '$userbase/Python$py_version_nodot/Include/$dist_name',
-        'scripts': '$userbase/Python$py_version_nodot/Scripts',
+        'headers': '$userbase/include/python$py_version_short$abiflags/$dist_name',
+        'scripts': '$userbase/bin',
         'data'   : '$userbase',
         }
 
@@ -341,7 +341,8 @@ class install(Command):
 
         # Convert directories from Unix /-separated syntax to the local
         # convention.
-        self.convert_paths('lib', 'purelib', 'platlib',
+        self.convert_paths('base', 'platbase',
+                           'lib', 'purelib', 'platlib',
                            'scripts', 'data', 'headers',
                            'userbase', 'usersite')
 
diff --git a/Lib/distutils/cygwinccompiler.py b/Lib/distutils/cygwinccompiler.py
index 1c36990..43f092e 100644
--- a/Lib/distutils/cygwinccompiler.py
+++ b/Lib/distutils/cygwinccompiler.py
@@ -48,7 +48,6 @@ cygwin in no-cygwin mode).
 import os
 import sys
 import copy
-from subprocess import Popen, PIPE, check_output
 import re
 
 from distutils.ccompiler import gen_preprocess_options, gen_lib_options
@@ -59,6 +58,7 @@ from distutils.errors import (DistutilsExecError, CCompilerError,
 from distutils import log
 from distutils.version import LooseVersion
 from distutils.spawn import find_executable
+from subprocess import Popen, PIPE, check_output
 
 def get_msvcr():
     """Include the appropriate MSVC runtime library if Python was built
@@ -93,6 +93,7 @@ class CygwinCCompiler(UnixCCompiler):
     obj_extension = ".o"
     static_lib_extension = ".a"
     shared_lib_extension = ".dll"
+    dylib_lib_extension = ".dll.a"
     static_lib_format = "lib%s%s"
     shared_lib_format = "%s%s"
     exe_extension = ".exe"
@@ -237,7 +238,7 @@ class CygwinCCompiler(UnixCCompiler):
         # (On my machine: 10KB < stripped_file < ??100KB
         #   unstripped_file = stripped_file + XXX KB
         #  ( XXX=254 for a typical python extension))
-        if not debug:
+        if not debug and not hasattr(sys, 'gettotalrefcount'):
             extra_preargs.append("-s")
 
         UnixCCompiler.link(self, target_desc, objects, output_filename,
@@ -255,11 +256,16 @@ class CygwinCCompiler(UnixCCompiler):
             output_dir = ''
         obj_names = []
         for src_name in source_filenames:
-            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
-            base, ext = os.path.splitext(os.path.normcase(src_name))
+            base, ext = os.path.splitext(src_name)
+            # use 'normcase' only for resource suffixes
+            ext_normcase = os.path.normcase(ext)
+            if ext_normcase in ['.rc','.res']:
+                ext = ext_normcase
             if ext not in (self.src_extensions + ['.rc','.res']):
                 raise UnknownFileError("unknown file type '%s' (from '%s')" % \
                       (ext, src_name))
+            base = os.path.splitdrive(base)[1] # Chop off the drive
+            base = base[os.path.isabs(base):]  # If abs, chop off leading /
             if strip_dir:
                 base = os.path.basename (base)
             if ext in ('.res', '.rc'):
@@ -299,9 +305,9 @@ class Mingw32CCompiler(CygwinCCompiler):
             raise CCompilerError(
                 'Cygwin gcc cannot be used with --compiler=mingw32')
 
-        self.set_executables(compiler='gcc -O -Wall',
-                             compiler_so='gcc -mdll -O -Wall',
-                             compiler_cxx='g++ -O -Wall',
+        self.set_executables(compiler='gcc -O2 -Wall',
+                             compiler_so='gcc -mdll -O2 -Wall',
+                             compiler_cxx='g++ -O2 -Wall',
                              linker_exe='gcc',
                              linker_so='%s %s %s'
                                         % (self.linker_dll, shared_option,
@@ -315,7 +321,7 @@ class Mingw32CCompiler(CygwinCCompiler):
 
         # Include the appropriate MSVC runtime library if Python was built
         # with MSVC 7.0 or later.
-        self.dll_libraries = get_msvcr()
+        self.dll_libraries = get_msvcr() or []
 
 # Because these compilers aren't configured in Python's pyconfig.h file by
 # default, we should at least warn the user if he is using an unmodified
@@ -368,7 +374,7 @@ def check_config_h():
         return (CONFIG_H_UNCERTAIN,
                 "couldn't read '%s': %s" % (fn, exc.strerror))
 
-RE_VERSION = re.compile(br'(\d+\.\d+(\.\d+)*)')
+RE_VERSION = re.compile(br'[\D\s]*(\d+\.\d+(\.\d+)*)[\D\s]*$')
 
 def _find_exe_version(cmd):
     """Find the version of an executable by running `cmd` in the shell.
@@ -379,6 +385,7 @@ def _find_exe_version(cmd):
     executable = cmd.split()[0]
     if find_executable(executable) is None:
         return None
+    from subprocess import Popen, PIPE
     out = Popen(cmd, shell=True, stdout=PIPE).stdout
     try:
         out_string = out.read()
@@ -396,7 +403,16 @@ def get_versions():
 
     If not possible it returns None for it.
     """
-    commands = ['gcc -dumpversion', 'ld -v', 'dllwrap --version']
+    gcc = os.environ.get('CC') or 'gcc'
+    ld = 'ld'
+    out = Popen(gcc+' --print-prog-name ld', shell=True, stdout=PIPE).stdout
+    try:
+        ld = test=str(out.read(),encoding='utf-8').strip()
+    finally:
+        out.close()
+    dllwrap = os.environ.get('DLLWRAP') or 'dllwrap'
+    # MinGW64 doesn't have i686-w64-mingw32-ld, so instead we ask gcc.
+    commands = [gcc+' -dumpversion', ld+' -v', dllwrap+' --version']
     return tuple([_find_exe_version(cmd) for cmd in commands])
 
 def is_cygwingcc():
diff --git a/Lib/distutils/spawn.py b/Lib/distutils/spawn.py
index 5dd415a..65735c2 100644
--- a/Lib/distutils/spawn.py
+++ b/Lib/distutils/spawn.py
@@ -12,6 +12,7 @@ import os
 from distutils.errors import DistutilsPlatformError, DistutilsExecError
 from distutils.debug import DEBUG
 from distutils import log
+from subprocess import list2cmdline
 
 def spawn(cmd, search_path=1, verbose=0, dry_run=0):
     """Run another program, specified as a command list 'cmd', in a new process.
@@ -43,17 +44,13 @@ def spawn(cmd, search_path=1, verbose=0, dry_run=0):
 def _nt_quote_args(args):
     """Quote command-line arguments for DOS/Windows conventions.
 
-    Just wraps every argument which contains blanks in double quotes, and
-    returns a new argument list.
+    Defer to subprocess module's list2cmdline as the logic is
+    complex. The previous implementation here failed to handle
+    -DG_LOG_DOMAIN="GEGL-"__FILE__ which was encountered in MSYS2
+    while building the gobject-introspection part of GEGL 0.3.4.
     """
-    # XXX this doesn't seem very robust to me -- but if the Windows guys
-    # say it'll work, I guess I'll have to accept it.  (What if an arg
-    # contains quotes?  What other magic characters, other than spaces,
-    # have to be escaped?  Is there an escaping mechanism other than
-    # quoting?)
     for i, arg in enumerate(args):
-        if ' ' in arg:
-            args[i] = '"%s"' % arg
+        args[i] = list2cmdline([args[i]])
     return args
 
 def _spawn_nt(cmd, search_path=1, verbose=0, dry_run=0):
diff --git a/Lib/distutils/sysconfig.py b/Lib/distutils/sysconfig.py
index 2bcd1dd..28b3fd6 100644
--- a/Lib/distutils/sysconfig.py
+++ b/Lib/distutils/sysconfig.py
@@ -53,6 +53,17 @@ def _python_build():
     return _is_python_source_dir(project_base)
 python_build = _python_build()
 
+def _posix_build():
+    # GCC[mingw*] use posix build system
+    # Check for cross builds explicitly
+    host_platform = os.environ.get("_PYTHON_HOST_PLATFORM")
+    if host_platform:
+        if host_platform.startswith('mingw'):
+            return True
+    return os.name == 'posix' or \
+        (os.name == "nt" and 'GCC' in sys.version)
+posix_build = _posix_build()
+
 # Calculate the build qualifier flags if they are defined.  Adding the flags
 # to the include and lib directories only makes sense for an installation, not
 # an in-source build.
@@ -86,7 +97,7 @@ def get_python_inc(plat_specific=0, prefix=None):
     """
     if prefix is None:
         prefix = plat_specific and BASE_EXEC_PREFIX or BASE_PREFIX
-    if os.name == "posix":
+    if posix_build:
         if python_build:
             # Assume the executable is in the build directory.  The
             # pyconfig.h file should be in the same directory.  Since
@@ -128,7 +139,7 @@ def get_python_lib(plat_specific=0, standard_lib=0, prefix=None):
         else:
             prefix = plat_specific and EXEC_PREFIX or PREFIX
 
-    if os.name == "posix":
+    if posix_build:
         libpython = os.path.join(prefix,
                                  "lib", "python" + get_python_version())
         if standard_lib:
@@ -153,7 +164,23 @@ def customize_compiler(compiler):
     Mainly needed on Unix, so we can plug in the information that
     varies across Unices and is stored in Python's Makefile.
     """
-    if compiler.compiler_type == "unix":
+    global _config_vars
+    if compiler.compiler_type in ["cygwin", "mingw32"]:
+        # Note that cygwin use posix build and 'unix' compiler.
+        # If build is not based on posix then we must predefine
+        # some environment variables corresponding to posix
+        # build rules and defaults.
+        if not 'GCC' in sys.version:
+            _config_vars['CC'] = "gcc"
+            _config_vars['CXX'] = "g++"
+            _config_vars['OPT'] = "-fwrapv -O3 -Wall -Wstrict-prototypes"
+            _config_vars['CFLAGS'] = ""
+            _config_vars['CCSHARED'] = ""
+            _config_vars['LDSHARED'] = "gcc -shared -Wl,--enable-auto-image-base"
+            _config_vars['AR'] = "ar"
+            _config_vars['ARFLAGS'] = "rc"
+
+    if compiler.compiler_type in ["unix", "cygwin", "mingw32"]:
         if sys.platform == "darwin":
             # Perform first-time customization of compiler-related
             # config vars on OS X now that we know we need a compiler.
@@ -163,7 +190,6 @@ def customize_compiler(compiler):
             # that Python itself was built on.  Also the user OS
             # version and build tools may not support the same set
             # of CPU architectures for universal builds.
-            global _config_vars
             # Use get_config_var() to ensure _config_vars is initialized.
             if not get_config_var('CUSTOMIZED_OSX_COMPILER'):
                 import _osx_support
@@ -223,7 +249,7 @@ def customize_compiler(compiler):
 def get_config_h_filename():
     """Return full pathname of installed pyconfig.h file."""
     if python_build:
-        if os.name == "nt":
+        if os.name == "nt" and not posix_build:
             inc_dir = os.path.join(_sys_home or project_base, "PC")
         else:
             inc_dir = _sys_home or project_base
@@ -429,6 +455,9 @@ def _init_posix():
 
 
 def _init_nt():
+    if posix_build:
+        _init_posix()
+        return
     """Initialize the module as appropriate for NT"""
     g = {}
     # set basic install directories
@@ -478,7 +507,7 @@ def get_config_vars(*args):
 
         # Always convert srcdir to an absolute path
         srcdir = _config_vars.get('srcdir', project_base)
-        if os.name == 'posix':
+        if posix_build:
             if python_build:
                 # If srcdir is a relative path (typically '.' or '..')
                 # then it should be interpreted relative to the directory
@@ -497,7 +526,7 @@ def get_config_vars(*args):
         # Normally it is relative to the build directory.  However, during
         # testing, for example, we might be running a non-installed python
         # from a different directory.
-        if python_build and os.name == "posix":
+        if python_build and posix_build:
             base = project_base
             if (not os.path.isabs(_config_vars['srcdir']) and
                 base != os.getcwd()):
diff --git a/Lib/distutils/unixccompiler.py b/Lib/distutils/unixccompiler.py
index 3f321c2..a261a18 100644
--- a/Lib/distutils/unixccompiler.py
+++ b/Lib/distutils/unixccompiler.py
@@ -242,9 +242,13 @@ class UnixCCompiler(CCompiler):
                 # -Wl whenever gcc was used in the past it is probably
                 # safest to keep doing so.
                 if sysconfig.get_config_var("GNULD") == "yes":
-                    # GNU ld needs an extra option to get a RUNPATH
+                    # GNU ELF ld needs an extra option to get a RUNPATH
                     # instead of just an RPATH.
-                    return "-Wl,--enable-new-dtags,-R" + dir
+                    if sys.platform in ["win32", "cygwin"] or \
+                       "mingw" in compiler:
+                        return []
+                    else:
+                        return "-Wl,--enable-new-dtags,-R" + dir
                 else:
                     return "-Wl,-R" + dir
             else:
diff --git a/Lib/distutils/util.py b/Lib/distutils/util.py
index fdcf6fa..f897663 100644
--- a/Lib/distutils/util.py
+++ b/Lib/distutils/util.py
@@ -40,6 +40,8 @@ def get_platform ():
     For other non-POSIX platforms, currently just returns 'sys.platform'.
     """
     if os.name == 'nt':
+        if 'GCC' in sys.version:
+            return 'mingw'
         # sniff sys.version for architecture.
         prefix = " bit ("
         i = sys.version.find(prefix)
@@ -131,6 +133,13 @@ def convert_path (pathname):
         paths.remove('.')
     if not paths:
         return os.curdir
+    # On Windows, if paths is ['C:','folder','subfolder'] then
+    # os.path.join(*paths) will return 'C:folder\subfolder' which
+    # is thus relative to the CWD on that drive. So we work around
+    # this by adding a \ to path[0]
+    if (len(paths) > 0 and paths[0].endswith(':') and
+        sys.platform == "win32" and sys.version.find("GCC") >= 0):
+        paths[0] += '\\'
     return os.path.join(*paths)
 
 # convert_path ()
@@ -141,6 +150,10 @@ def change_root (new_root, pathname):
     relative, this is equivalent to "os.path.join(new_root,pathname)".
     Otherwise, it requires making 'pathname' relative and then joining the
     two, which is tricky on DOS/Windows and Mac OS.
+
+    If on Windows or OS/2 and both new_root and pathname are on different
+    drives, raises DistutilsChangeRootError as this is nonsensical,
+    otherwise use drive which can be in either of new_root or pathname.
     """
     if os.name == 'posix':
         if not os.path.isabs(pathname):
@@ -150,9 +163,20 @@ def change_root (new_root, pathname):
 
     elif os.name == 'nt':
         (drive, path) = os.path.splitdrive(pathname)
-        if path[0] == '\\':
+        if path[0] == os.sep:
             path = path[1:]
-        return os.path.join(new_root, path)
+        (drive_r, path_r) = os.path.splitdrive(new_root)
+        if path_r and path_r[0] == os.sep:
+            path_r = path_r[1:]
+        drive_used = ''
+        if len(drive) == 2 and len(drive_r) == 2 and drive != drive_r:
+            raise DistutilsChangeRootError("root and pathname not on same drive (%s, %s)"
+                   % (drive_r,drive))
+        elif len(drive_r) == 2:
+            drive_used = drive_r+os.sep
+        elif len(drive) == 2:
+            drive_used = drive+os.sep
+        return os.path.join(drive_used+path_r, path)
 
     else:
         raise DistutilsPlatformError("nothing known about platform '%s'" % os.name)
diff --git a/Lib/ntpath.py b/Lib/ntpath.py
index a8f4b37..14b56ae 100644
--- a/Lib/ntpath.py
+++ b/Lib/ntpath.py
@@ -24,17 +24,41 @@ __all__ = ["normcase","isabs","join","splitdrive","split","splitext",
 curdir = '.'
 pardir = '..'
 extsep = '.'
-sep = '\\'
+if sys.platform == "win32" and "MSYSTEM" in os.environ:
+    sep = '/'
+    altsep = '\\'
+else:
+    sep = '\\'
+    altsep = '/'
+bsep = str.encode(sep)
+baltsep = str.encode(altsep)
 pathsep = ';'
-altsep = '/'
 defpath = '.;C:\\bin'
 devnull = 'nul'
 
 def _get_bothseps(path):
     if isinstance(path, bytes):
-        return b'\\/'
+        return bsep+baltsep
     else:
-        return '\\/'
+        return sep+altsep
+
+def _get_sep(path):
+    if isinstance(path, bytes):
+        return bsep
+    else:
+        return sep
+
+def _get_altsep(path):
+    if isinstance(path, bytes):
+        return baltsep
+    else:
+        return altsep
+
+def _get_colon(path):
+    if isinstance(path, bytes):
+        return b':'
+    else:
+        return ':'
 
 # Normalize the case of a pathname and map slashes to backslashes.
 # Other normalizations (such as optimizing '../' away) are not done
@@ -47,9 +71,9 @@ def normcase(s):
     s = os.fspath(s)
     try:
         if isinstance(s, bytes):
-            return s.replace(b'/', b'\\').lower()
+            return s.replace(baltsep, bsep).lower()
         else:
-            return s.replace('/', '\\').lower()
+            return s.replace(altsep, sep).lower()
     except (TypeError, AttributeError):
         if not isinstance(s, (bytes, str)):
             raise TypeError("normcase() argument must be str or bytes, "
@@ -73,14 +97,9 @@ def isabs(s):
 # Join two (or more) paths.
 def join(path, *paths):
     path = os.fspath(path)
-    if isinstance(path, bytes):
-        sep = b'\\'
-        seps = b'\\/'
-        colon = b':'
-    else:
-        sep = '\\'
-        seps = '\\/'
-        colon = ':'
+    sep = _get_sep(path)
+    seps = _get_bothseps(path)
+    colon = _get_colon(path)
     try:
         if not paths:
             path[:0] + sep  #23780: Ensure compatible data type even if p is null.
@@ -139,14 +158,9 @@ def splitdrive(p):
     """
     p = os.fspath(p)
     if len(p) >= 2:
-        if isinstance(p, bytes):
-            sep = b'\\'
-            altsep = b'/'
-            colon = b':'
-        else:
-            sep = '\\'
-            altsep = '/'
-            colon = ':'
+        sep = _get_sep(p)
+        altsep = _get_altsep(p)
+        colon = _get_colon(p)
         normp = p.replace(altsep, sep)
         if (normp[0:2] == sep*2) and (normp[2:3] != sep):
             # is a UNC path:
@@ -222,9 +236,9 @@ def split(p):
 def splitext(p):
     p = os.fspath(p)
     if isinstance(p, bytes):
-        return genericpath._splitext(p, b'\\', b'/', b'.')
+        return genericpath._splitext(p, bsep, baltsep, b'.')
     else:
-        return genericpath._splitext(p, '\\', '/', '.')
+        return genericpath._splitext(p, sep, altsep, '.')
 splitext.__doc__ = genericpath._splitext.__doc__
 
 
@@ -471,15 +485,13 @@ def expandvars(path):
 def normpath(path):
     """Normalize path, eliminating double slashes, etc."""
     path = os.fspath(path)
+    sep = _get_sep(path)
+    altsep = _get_altsep(path)
     if isinstance(path, bytes):
-        sep = b'\\'
-        altsep = b'/'
         curdir = b'.'
         pardir = b'..'
         special_prefixes = (b'\\\\.\\', b'\\\\?\\')
     else:
-        sep = '\\'
-        altsep = '/'
         curdir = '.'
         pardir = '..'
         special_prefixes = ('\\\\.\\', '\\\\?\\')
@@ -559,12 +571,11 @@ supports_unicode_filenames = (hasattr(sys, "getwindowsversion") and
 def relpath(path, start=None):
     """Return a relative version of a path"""
     path = os.fspath(path)
+    sep = _get_sep(path)
     if isinstance(path, bytes):
-        sep = b'\\'
         curdir = b'.'
         pardir = b'..'
     else:
-        sep = '\\'
         curdir = '.'
         pardir = '..'
 
@@ -619,13 +630,11 @@ def commonpath(paths):
         raise ValueError('commonpath() arg is an empty sequence')
 
     paths = tuple(map(os.fspath, paths))
+    sep = _get_sep(paths[0])
+    altsep = _get_altsep(paths[0])
     if isinstance(paths[0], bytes):
-        sep = b'\\'
-        altsep = b'/'
         curdir = b'.'
     else:
-        sep = '\\'
-        altsep = '/'
         curdir = '.'
 
     try:
diff --git a/Lib/site.py b/Lib/site.py
index 0fc9200..5ed4c38 100644
--- a/Lib/site.py
+++ b/Lib/site.py
@@ -268,6 +268,12 @@ def getusersitepackages():
             USER_SITE = get_path('purelib', 'osx_framework_user')
             return USER_SITE
 
+    if sys.platform == 'win32':
+        from sysconfig import _POSIX_BUILD
+        if _POSIX_BUILD:
+            USER_SITE = get_path('purelib', 'posix_user')
+            return USER_SITE
+
     USER_SITE = get_path('purelib', '%s_user' % os.name)
     return USER_SITE
 
@@ -298,12 +304,13 @@ def getsitepackages(prefixes=None):
     if prefixes is None:
         prefixes = PREFIXES
 
+    from sysconfig import _POSIX_BUILD
     for prefix in prefixes:
         if not prefix or prefix in seen:
             continue
         seen.add(prefix)
 
-        if os.sep == '/':
+        if _POSIX_BUILD:
             sitepackages.append(os.path.join(prefix, "lib",
                                         "python%d.%d" % sys.version_info[:2],
                                         "site-packages"))
diff --git a/Lib/ssl.py b/Lib/ssl.py
index 1f3a31a..ee5ceb3 100644
--- a/Lib/ssl.py
+++ b/Lib/ssl.py
@@ -156,7 +156,7 @@ _PROTOCOL_NAMES = {value: name for name, value in _SSLMethod.__members__.items()
 _SSLv2_IF_EXISTS = getattr(_SSLMethod, 'PROTOCOL_SSLv2', None)
 
 
-if sys.platform == "win32":
+if sys.platform == "win32" and sys.version.find("GCC") == -1:
     from _ssl import enum_certificates, enum_crls
 
 from socket import socket, AF_INET, SOCK_STREAM, create_connection
@@ -451,7 +451,7 @@ class SSLContext(_SSLContext):
     def load_default_certs(self, purpose=Purpose.SERVER_AUTH):
         if not isinstance(purpose, _ASN1Object):
             raise TypeError(purpose)
-        if sys.platform == "win32":
+        if sys.platform == "win32" and sys.version.find("GCC") == -1:
             for storename in self._windows_cert_stores:
                 self._load_windows_store_certs(storename, purpose)
         self.set_default_verify_paths()
diff --git a/Lib/sysconfig.py b/Lib/sysconfig.py
index 9314e71..13de0aa 100644
--- a/Lib/sysconfig.py
+++ b/Lib/sysconfig.py
@@ -42,22 +42,22 @@ _INSTALL_SCHEMES = {
         'data': '{base}',
         },
     'nt': {
-        'stdlib': '{installed_base}/Lib',
-        'platstdlib': '{base}/Lib',
-        'purelib': '{base}/Lib/site-packages',
-        'platlib': '{base}/Lib/site-packages',
-        'include': '{installed_base}/Include',
-        'platinclude': '{installed_base}/Include',
-        'scripts': '{base}/Scripts',
+        'stdlib': '{installed_base}/lib/python{py_version_short}',
+        'platstdlib': '{base}/lib/python{py_version_short}',
+        'purelib': '{base}/lib/python{py_version_short}',
+        'platlib': '{base}/lib/python{py_version_short}',
+        'include': '{installed_base}/include/python{py_version_short}',
+        'platinclude': '{installed_base}/include/python{py_version_short}',
+        'scripts': '{base}/bin',
         'data': '{base}',
         },
     'nt_user': {
-        'stdlib': '{userbase}/Python{py_version_nodot}',
-        'platstdlib': '{userbase}/Python{py_version_nodot}',
-        'purelib': '{userbase}/Python{py_version_nodot}/site-packages',
-        'platlib': '{userbase}/Python{py_version_nodot}/site-packages',
-        'include': '{userbase}/Python{py_version_nodot}/Include',
-        'scripts': '{userbase}/Python{py_version_nodot}/Scripts',
+        'stdlib': '{userbase}/lib/python{py_version_short}',
+        'platstdlib': '{userbase}/lib/python{py_version_short}',
+        'purelib': '{userbase}/lib/python{py_version_short}/site-packages',
+        'platlib': '{userbase}/lib/python{py_version_short}/site-packages',
+        'include': '{userbase}/include/python{py_version_short}',
+        'scripts': '{userbase}/bin',
         'data': '{userbase}',
         },
     'posix_user': {
@@ -95,6 +95,9 @@ _BASE_EXEC_PREFIX = os.path.normpath(sys.base_exec_prefix)
 _CONFIG_VARS = None
 _USER_BASE = None
 
+# GCC[mingw*] use posix build system
+_POSIX_BUILD = os.name == 'posix' or \
+    (os.name == "nt" and 'GCC' in sys.version)
 
 def _safe_realpath(path):
     try:
@@ -171,7 +174,7 @@ def _expand_vars(scheme, vars):
 
 
 def _get_default_scheme():
-    if os.name == 'posix':
+    if _POSIX_BUILD:
         # the default scheme for posix is posix_prefix
         return 'posix_prefix'
     return os.name
@@ -183,7 +186,7 @@ def _getuserbase():
     def joinuser(*args):
         return os.path.expanduser(os.path.join(*args))
 
-    if os.name == "nt":
+    if os.name == "nt" and not _POSIX_BUILD:
         base = os.environ.get("APPDATA") or "~"
         if env_base:
             return env_base
@@ -257,6 +260,7 @@ def _parse_makefile(filename, vars=None):
     # if the expansion uses the name without a prefix.
     renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')
 
+    done['prefix']='${SYS_PREFIX}'
     while len(variables) > 0:
         for name in tuple(variables):
             value = notdone[name]
@@ -324,6 +328,14 @@ def _parse_makefile(filename, vars=None):
         if isinstance(v, str):
             done[k] = v.strip()
 
+    # any keys that have one with the same name suffixed with _b2h
+    # need to be replaced with the value of the _b2h key.
+    # This converts from MSYS*/Cygwin paths to Windows paths.
+    for k, v in dict(done).items():
+        if isinstance(k, str):
+            if k.endswith("_b2h"):
+                done[k[:-4]]=v
+
     # save the results in the global dictionary
     vars.update(done)
     return vars
@@ -410,6 +422,19 @@ def _generate_posix_vars():
         f.write('build_time_vars = ')
         pprint.pprint(vars, stream=f)
 
+    # Now reload the file and replace:
+    replacements = {": '${SYS_PREFIX}'" : ": sys.prefix",
+                    ": '${SYS_PREFIX}"  : ": sys.prefix + '",
+                     "${SYS_PREFIX}'" : "' + sys.prefix",
+                     "${SYS_PREFIX}"  : "' + sys.prefix + '"}
+
+    contents = open(destfile).read()
+    for rep in replacements.keys():
+        contents = contents.replace(rep, replacements[rep])
+    with open(destfile, 'w', encoding='utf8') as f:
+        f.write('import sys\n')
+        f.write(contents)
+
     # Create file used for sys.path fixup -- see Modules/getpath.c
     with open('pybuilddir.txt', 'w', encoding='ascii') as f:
         f.write(pybuilddir)
@@ -430,7 +455,7 @@ def _init_non_posix(vars):
     vars['INCLUDEPY'] = get_path('include')
     vars['EXT_SUFFIX'] = '.pyd'
     vars['EXE'] = '.exe'
-    vars['VERSION'] = _PY_VERSION_SHORT_NO_DOT
+    vars['VERSION'] = _PY_VERSION_SHORT
     vars['BINDIR'] = os.path.dirname(_safe_realpath(sys.executable))
 
 #
@@ -473,7 +498,7 @@ def parse_config_h(fp, vars=None):
 def get_config_h_filename():
     """Return the path of pyconfig.h."""
     if _PYTHON_BUILD:
-        if os.name == "nt":
+        if os.name == "nt" and not _POSIX_BUILD:
             inc_dir = os.path.join(_sys_home or _PROJECT_BASE, "PC")
         else:
             inc_dir = _sys_home or _PROJECT_BASE
@@ -544,9 +569,9 @@ def get_config_vars(*args):
             # sys.abiflags may not be defined on all platforms.
             _CONFIG_VARS['abiflags'] = ''
 
-        if os.name == 'nt':
+        if os.name == 'nt' and not _POSIX_BUILD:
             _init_non_posix(_CONFIG_VARS)
-        if os.name == 'posix':
+        if _POSIX_BUILD:
             _init_posix(_CONFIG_VARS)
         # For backward compatibility, see issue19555
         SO = _CONFIG_VARS.get('EXT_SUFFIX')
@@ -559,7 +584,7 @@ def get_config_vars(*args):
 
         # Always convert srcdir to an absolute path
         srcdir = _CONFIG_VARS.get('srcdir', _PROJECT_BASE)
-        if os.name == 'posix':
+        if _POSIX_BUILD:
             if _PYTHON_BUILD:
                 # If srcdir is a relative path (typically '.' or '..')
                 # then it should be interpreted relative to the directory
@@ -627,6 +652,8 @@ def get_platform():
     For other non-POSIX platforms, currently just returns 'sys.platform'.
     """
     if os.name == 'nt':
+        if 'GCC' in sys.version:
+            return 'mingw'
         # sniff sys.version for architecture.
         prefix = " bit ("
         i = sys.version.find(prefix)
diff --git a/Makefile.pre.in b/Makefile.pre.in
index 6cb0c63..233baeb 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -106,11 +106,12 @@ ARFLAGS=	@ARFLAGS@
 # Extra C flags added for building the interpreter object files.
 CFLAGSFORSHARED=@CFLAGSFORSHARED@
 # C flags used for building the interpreter object files
-PY_CORE_CFLAGS=	$(PY_CFLAGS) $(PY_CFLAGS_NODIST) $(PY_CPPFLAGS) $(CFLAGSFORSHARED) -DPy_BUILD_CORE
+PY_CORE_CFLAGS=	$(PY_CFLAGS) $(PY_CFLAGS_NODIST) $(PY_CPPFLAGS) $(CFLAGSFORSHARED) -DPy_BUILD_CORE -D_WIN32_WINNT=0x0601
 # Strict or non-strict aliasing flags used to compile dtoa.c, see above
 CFLAGS_ALIASING=@CFLAGS_ALIASING@
 
-
+# ; on Windows otherwise :
+DELIM=		@DELIM@
 # Machine-dependent subdirectories
 MACHDEP=	@MACHDEP@
 
@@ -127,6 +128,13 @@ exec_prefix=	@exec_prefix@
 # Install prefix for data files
 datarootdir=    @datarootdir@
 
+# Locations needed for semi-native fixup of sysconfig.
+srcdir_b2h=		@srcdir_b2h@
+VPATH_b2h=		@VPATH_b2h@
+abs_srcdir_b2h=		@abs_srcdir_b2h@
+abs_builddir_b2h=	@abs_builddir_b2h@
+prefix_b2h=		@prefix_b2h@
+
 # Expanded directories
 BINDIR=		@bindir@
 LIBDIR=		@libdir@
@@ -257,7 +265,7 @@ COVERAGE_REPORT_OPTIONS=--no-branch-coverage --title "CPython lcov report"
 # Modules
 MODULE_OBJS=	\
 		Modules/config.o \
-		Modules/getpath.o \
+		@MODULE_GETPATH@ \
 		Modules/main.o \
 		Modules/gcmodule.o
 
@@ -325,7 +333,7 @@ PYTHON_OBJS=	\
 		Python/codecs.o \
 		Python/dynamic_annotations.o \
 		Python/errors.o \
-		Python/frozenmain.o \
+		@PYTHON_OBJS_FROZENMAIN@ \
 		Python/future.o \
 		Python/getargs.o \
 		Python/getcompiler.o \
@@ -335,6 +343,7 @@ PYTHON_OBJS=	\
 		Python/graminit.o \
 		Python/import.o \
 		Python/importdl.o \
+		Python/iscygpty.o \
 		Python/marshal.o \
 		Python/modsupport.o \
 		Python/mystrtoul.o \
@@ -641,9 +650,9 @@ $(PYTHONFRAMEWORKDIR)/Versions/$(VERSION)/$(PYTHONFRAMEWORK): \
 	$(LN) -fsn Versions/Current/$(PYTHONFRAMEWORK) $(PYTHONFRAMEWORKDIR)/$(PYTHONFRAMEWORK)
 	$(LN) -fsn Versions/Current/Resources $(PYTHONFRAMEWORKDIR)/Resources
 
-# This rule builds the Cygwin Python DLL and import library if configured
+# This rule builds the Python DLL and import library if configured
 # for a shared core library; otherwise, this rule is a noop.
-$(DLLLIBRARY) libpython$(VERSION).dll.a: $(LIBRARY_OBJS)
+$(DLLLIBRARY) libpython$(LDVERSION).dll.a: $(LIBRARY_OBJS)
 	if test -n "$(DLLLIBRARY)"; then \
 		$(LDSHARED) -Wl,--out-implib=$@ -o $(DLLLIBRARY) $^ \
 			$(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST); \
@@ -687,19 +696,19 @@ Programs/_testembed: Programs/_testembed.o $(LIBRARY) $(LDLIBRARY) $(PY3LIBRARY)
 
 Programs/_freeze_importlib.o: Programs/_freeze_importlib.c Makefile
 
-Programs/_freeze_importlib: Programs/_freeze_importlib.o $(LIBRARY_OBJS_OMIT_FROZEN)
+Programs/_freeze_importlib$(EXE): Programs/_freeze_importlib.o $(LIBRARY_OBJS_OMIT_FROZEN)
 	$(LINKCC) $(PY_LDFLAGS) -o $@ Programs/_freeze_importlib.o $(LIBRARY_OBJS_OMIT_FROZEN) $(LIBS) $(MODLIBS) $(SYSLIBS) $(LDLAST)
 
 .PHONY: regen-importlib
-regen-importlib: Programs/_freeze_importlib
+regen-importlib: Programs/_freeze_importlib$(EXE)
 	# Regenerate Python/importlib_external.h
 	# from Lib/importlib/_bootstrap_external.py using _freeze_importlib
-	./Programs/_freeze_importlib \
+	./Programs/_freeze_importlib$(EXE) \
 	    $(srcdir)/Lib/importlib/_bootstrap_external.py \
 	    $(srcdir)/Python/importlib_external.h
 	# Regenerate Python/importlib.h from Lib/importlib/_bootstrap.py
 	# using _freeze_importlib
-	./Programs/_freeze_importlib \
+	./Programs/_freeze_importlib$(EXE) \
 	    $(srcdir)/Lib/importlib/_bootstrap.py \
 	    $(srcdir)/Python/importlib.h
 
@@ -724,6 +733,7 @@ Modules/getbuildinfo.o: $(PARSER_OBJS) \
 	      -DGITBRANCH="\"`LC_ALL=C $(GITBRANCH)`\"" \
 	      -o $@ $(srcdir)/Modules/getbuildinfo.c
 
+# default sys.path calculations for posix platforms
 Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
 	$(CC) -c $(PY_CORE_CFLAGS) -DPYTHONPATH='"$(PYTHONPATH)"' \
 		-DPREFIX='"$(prefix)"' \
@@ -732,6 +742,13 @@ Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
 		-DVPATH='"$(VPATH)"' \
 		-o $@ $(srcdir)/Modules/getpath.c
 
+# default sys.path calculations for windows platforms
+PC/getpathp.o: $(srcdir)/PC/getpathp.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) \
+		-DVERSION='"$(VERSION)"' \
+		-DSRCDIR='"$(srcdir)"' \
+		-o $@ $(srcdir)/PC/getpathp.c
+
 Programs/python.o: $(srcdir)/Programs/python.c
 	$(MAINCC) -c $(PY_CORE_CFLAGS) -o $@ $(srcdir)/Programs/python.c
 
@@ -758,6 +775,12 @@ Python/dynload_hpux.o: $(srcdir)/Python/dynload_hpux.c Makefile
 		-DSHLIB_EXT='"$(EXT_SUFFIX)"' \
 		-o $@ $(srcdir)/Python/dynload_hpux.c
 
+Python/dynload_win.o: $(srcdir)/Python/dynload_win.c Makefile
+	$(CC) -c $(PY_CORE_CFLAGS) \
+		-DSHLIB_SUFFIX='"$(SHLIB_SUFFIX)"' \
+		-DEXT_SUFFIX='"$(EXT_SUFFIX)"' \
+		-o $@ $(srcdir)/Python/dynload_win.c
+
 Python/sysmodule.o: $(srcdir)/Python/sysmodule.c Makefile
 	$(CC) -c $(PY_CORE_CFLAGS) \
 		-DABIFLAGS='"$(ABIFLAGS)"' \
@@ -931,6 +954,7 @@ PYTHON_HEADERS= \
 		$(srcdir)/Include/genobject.h \
 		$(srcdir)/Include/import.h \
 		$(srcdir)/Include/intrcheck.h \
+		$(srcdir)/Include/iscygpty.h \
 		$(srcdir)/Include/iterobject.h \
 		$(srcdir)/Include/listobject.h \
 		$(srcdir)/Include/longintrepr.h \
@@ -1259,6 +1283,7 @@ LIBSUBDIRS=	tkinter tkinter/test tkinter/test/test_tkinter \
 		test/test_importlib/import_ test/test_importlib/source \
 		test/test_tools test/test_warnings test/test_warnings/data \
 		turtledemo \
+		msilib \
 		multiprocessing multiprocessing/dummy \
 		unittest unittest/test unittest/test/testmock \
 		venv venv/scripts venv/scripts/common venv/scripts/posix \
@@ -1445,6 +1470,12 @@ libainstall:	@DEF_MAKE_RULE@ python-config
 	else true; \
 	fi
 
+ifeq ($(shell uname -o),Msys)
+DESTDIRFINAL=$(DESTDIR)
+else
+DESTDIRFINAL=$(DESTDIR)/
+endif
+
 # Install the dynamically loadable modules
 # This goes into $(exec_prefix)
 sharedinstall: sharedmods
@@ -1452,9 +1483,9 @@ sharedinstall: sharedmods
 	   	--prefix=$(prefix) \
 		--install-scripts=$(BINDIR) \
 		--install-platlib=$(DESTSHARED) \
-		--root=$(DESTDIR)/
-	-rm $(DESTDIR)$(DESTSHARED)/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py
-	-rm -r $(DESTDIR)$(DESTSHARED)/__pycache__
+		--root=$(DESTDIRFINAL)
+	-rm $(DESTDIRFINAL)$(DESTSHARED)/_sysconfigdata_$(ABIFLAGS)_$(MACHDEP)_$(MULTIARCH).py
+	-rm -r $(DESTDIRFINAL)$(DESTSHARED)/__pycache__
 
 # Here are a couple of targets for MacOSX again, to install a full
 # framework-based Python. frameworkinstall installs everything, the
@@ -1535,7 +1566,7 @@ scriptsinstall:
 	$(PYTHON_FOR_BUILD) $(srcdir)/Tools/scripts/setup.py install \
 	--prefix=$(prefix) \
 	--install-scripts=$(BINDIR) \
-	--root=$(DESTDIR)/
+	--root=$(DESTDIRFINAL)
 
 # Build the toplevel Makefile
 Makefile.pre: $(srcdir)/Makefile.pre.in config.status
@@ -1617,7 +1648,7 @@ clean: pycremoval
 	find build -name '*.py[co]' -exec rm -f {} ';' || true
 	-rm -f pybuilddir.txt
 	-rm -f Lib/lib2to3/*Grammar*.pickle
-	-rm -f Programs/_testembed Programs/_freeze_importlib
+	-rm -f Programs/_testembed Programs/_freeze_importlib$(EXE)
 	-find build -type f -a ! -name '*.gc??' -exec rm -f {} ';'
 	-rm -f Include/pydtrace_probes.h
 
diff --git a/Misc/config_mingw b/Misc/config_mingw
new file mode 100644
index 0000000..9be43fd
--- /dev/null
+++ b/Misc/config_mingw
@@ -0,0 +1,15 @@
+# configure defaults for mingw* hosts
+
+# mingw functions to ignore
+ac_cv_func_ftruncate=ignore	# implement it as _chsize
+
+# mingw-w64 functions to ignore
+ac_cv_func_truncate=ignore
+ac_cv_func_alarm=ignore
+
+# files to ignore
+ac_cv_file__dev_ptmx=ignore #NOTE: under MSYS environment device exist
+ac_cv_file__dev_ptc=no
+
+# force detection of winsock2 functionality - require wxp or newer
+ac_cv_func_getpeername=yes
diff --git a/Misc/cross_mingw32 b/Misc/cross_mingw32
new file mode 100644
index 0000000..03fde9e
--- /dev/null
+++ b/Misc/cross_mingw32
@@ -0,0 +1,11 @@
+# configure defaults for mingw32 host if cross-build
+
+ac_cv_little_endian_double=yes
+ac_cv_big_endian_double=no
+ac_cv_mixed_endian_double=no
+
+ac_cv_tanh_preserves_zero_sign=yes
+
+ac_cv_wchar_t_signed=no
+
+ac_cv_have_size_t_format=no
diff --git a/Misc/python-config.sh.in b/Misc/python-config.sh.in
index 30c6927..a3d225e 100644
--- a/Misc/python-config.sh.in
+++ b/Misc/python-config.sh.in
@@ -1,25 +1,37 @@
 #!/bin/sh
 
-# Keep this script in sync with python-config.in
-
 exit_with_usage ()
 {
     echo "Usage: $0 --prefix|--exec-prefix|--includes|--libs|--cflags|--ldflags|--extension-suffix|--help|--abiflags|--configdir"
-    exit $1
+    exit 1
 }
 
+# Really, python-config.py (and thus .sh) should be called directly, but
+# sometimes software (e.g. GDB) calls python-config.sh as if it were the
+# Python executable, passing python-config.py as the first argument.
+# Work around that oddness by ignoring any .py passed as first arg.
+case "$1" in
+    *.py)
+        shift
+    ;;
+esac
+
 if [ "$1" = "" ] ; then
-    exit_with_usage 1
+    exit_with_usage
 fi
 
 # Returns the actual prefix where this script was installed to.
 installed_prefix ()
 {
-    RESULT=$(dirname $(cd $(dirname "$1") && pwd -P))
-    if which readlink >/dev/null 2>&1 ; then
-        if readlink -f "$RESULT" >/dev/null 2>&1; then
-          RESULT=$(readlink -f "$RESULT")
-        fi
+    local RESULT=$(dirname $(cd $(dirname "$1") && pwd -P))
+    if [ $(which readlink) ] ; then
+        RESULT=$(readlink -f "$RESULT")
+    fi
+    # Since we don't know where the output from this script will end up
+    # we keep all paths in Windows-land since MSYS2 can handle that
+    # while native tools can't handle paths in MSYS2-land.
+    if [ "$OSTYPE" = "msys" ]; then
+        RESULT=$(cd "$RESULT" && pwd -W)
     fi
     echo $RESULT
 }
@@ -27,8 +39,7 @@ installed_prefix ()
 prefix_build="@prefix@"
 prefix_real=$(installed_prefix "$0")
 
-# Use sed to fix paths from their built-to locations to their installed-to
-# locations.
+# Use sed to fix paths from their built to locations to their installed to locations.
 prefix=$(echo "$prefix_build" | sed "s#$prefix_build#$prefix_real#")
 exec_prefix_build="@exec_prefix@"
 exec_prefix=$(echo "$exec_prefix_build" | sed "s#$exec_prefix_build#$prefix_real#")
@@ -40,13 +51,17 @@ LIBM="@LIBM@"
 LIBC="@LIBC@"
 SYSLIBS="$LIBM $LIBC"
 ABIFLAGS="@ABIFLAGS@"
+# Protect against lack of substitution.
+if [ "$ABIFLAGS" = "@""ABIFLAGS""@" ] ; then
+    ABIFLAGS=
+fi
 LIBS="-lpython${VERSION}${ABIFLAGS} @LIBS@ $SYSLIBS"
 BASECFLAGS="@BASECFLAGS@"
-LDLIBRARY="@LDLIBRARY@"
-LINKFORSHARED="@LINKFORSHARED@"
 OPT="@OPT@"
 PY_ENABLE_SHARED="@PY_ENABLE_SHARED@"
 LDVERSION="@LDVERSION@"
+LDLIBRARY="@LDLIBRARY@"
+LINKFORSHARED="@LINKFORSHARED@"
 LIBDEST=${prefix}/lib/python${VERSION}
 LIBPL=$(echo "@LIBPL@" | sed "s#$prefix_build#$prefix_real#")
 SO="@EXT_SUFFIX@"
@@ -59,33 +74,33 @@ for ARG in $*
 do
     case $ARG in
         --help)
-            exit_with_usage 0
+            exit_with_usage
         ;;
         --prefix|--exec-prefix|--includes|--libs|--cflags|--ldflags|--extension-suffix|--abiflags|--configdir)
         ;;
         *)
-            exit_with_usage 1
+            exit_with_usage
         ;;
     esac
 done
 
-for ARG in "$@"
+for ARG in $*
 do
-    case "$ARG" in
+    case $ARG in
         --prefix)
-            echo "$prefix"
+            echo -ne "$prefix"
         ;;
         --exec-prefix)
-            echo "$exec_prefix"
+            echo -ne "$exec_prefix "
         ;;
         --includes)
-            echo "$INCDIR $PLATINCDIR"
+            echo -ne "$INCDIR "
         ;;
         --cflags)
-            echo "$INCDIR $PLATINCDIR $BASECFLAGS $CFLAGS $OPT"
+            echo -ne "$INCDIR $BASECFLAGS $CFLAGS $OPT "
         ;;
         --libs)
-            echo "$LIBS"
+            echo -ne "$LIBS "
         ;;
         --ldflags)
             LINKFORSHAREDUSED=
@@ -96,16 +111,16 @@ do
             if [ "$PY_ENABLE_SHARED" = "0" ] ; then
                 LIBPLUSED="-L$LIBPL"
             fi
-            echo "$LIBPLUSED -L$libdir $LIBS $LINKFORSHAREDUSED"
+            echo -ne "$LIBPLUSED -L$libdir $LIBS $LINKFORSHAREDUSED "
         ;;
         --extension-suffix)
-            echo "$SO"
+            echo -ne "$SO "
         ;;
         --abiflags)
-            echo "$ABIFLAGS"
+            echo -ne "$ABIFLAGS "
         ;;
         --configdir)
-            echo "$LIBPL"
+            echo -ne "$LIBPL "
         ;;
 esac
 done
diff --git a/Modules/Setup.config.in b/Modules/Setup.config.in
index 6450528..c0f3aea 100644
--- a/Modules/Setup.config.in
+++ b/Modules/Setup.config.in
@@ -3,8 +3,19 @@
 # The purpose of this file is to conditionally enable certain modules
 # based on configure-time options.
 
+# init system calls(posix/nt/...) for INITFUNC (used by makesetup)
+@INITSYS@ posixmodule.c
+
+# This is needed to find out the user's home dir if $HOME is not set
+@USE_PWD_MODULE@pwd pwdmodule.c
+
 # Threading
 @USE_THREAD_MODULE@_thread _threadmodule.c
 
+# build-in modules for windows platform:
+@USE_WIN32_MODULE@winreg ../PC/winreg.c
+@USE_WIN32_MODULE@msvcrt ../PC/msvcrtmodule.c
+@USE_WIN32_MODULE@_winapi _winapi.c
+
 # The rest of the modules previously listed in this file are built
 # by the setup.py script in Python 2.1 and later.
diff --git a/Modules/Setup.dist b/Modules/Setup.dist
index 735bacb..5de6913 100644
--- a/Modules/Setup.dist
+++ b/Modules/Setup.dist
@@ -84,14 +84,14 @@ MACHDESTLIB=$(BINLIBDEST)
 # Empty since this is now just the runtime prefix.
 DESTPATH=
 
-# Site specific path components -- should begin with : if non-empty
+# Site specific path components -- should begin with $(DELIM) if non-empty
 SITEPATH=
 
 # Standard path components for test modules
 TESTPATH=
 
 # Path components for machine- or system-dependent modules and shared libraries
-MACHDEPPATH=:$(PLATDIR)
+MACHDEPPATH=$(DELIM)$(PLATDIR)
 EXTRAMACHDEPPATH=
 
 COREPYTHONPATH=$(DESTPATH)$(SITEPATH)$(TESTPATH)$(MACHDEPPATH)$(EXTRAMACHDEPPATH)
@@ -105,10 +105,7 @@ PYTHONPATH=$(COREPYTHONPATH)
 # This only contains the minimal set of modules required to run the
 # setup.py script in the root of the Python source tree.
 
-posix posixmodule.c		# posix (UNIX) system calls
 errno errnomodule.c		# posix (UNIX) errno values
-pwd pwdmodule.c			# this is needed to find out the user's home dir
-				# if $HOME is not set
 _sre _sre.c			# Fredrik Lundh's new regular expressions
 _codecs _codecsmodule.c		# access to the builtin codecs and codec registry
 _weakref _weakref.c		# weak references
@@ -117,7 +114,7 @@ _operator _operator.c	        # operator.add() and similar goodies
 _collections _collectionsmodule.c # Container types
 itertools itertoolsmodule.c    # Functions creating iterators for efficient looping
 atexit atexitmodule.c      # Register functions to be run at interpreter-shutdown
-_signal signalmodule.c
+_signal signalmodule.c -lws2_32
 _stat _stat.c			# stat.h interface
 time timemodule.c	# -lm # time operations and variables
 
@@ -125,7 +122,7 @@ time timemodule.c	# -lm # time operations and variables
 _locale _localemodule.c  # -lintl
 
 # Standard I/O baseline
-_io -I$(srcdir)/Modules/_io _io/_iomodule.c _io/iobase.c _io/fileio.c _io/bytesio.c _io/bufferedio.c _io/textio.c _io/stringio.c
+_io -I$(srcdir)/Modules/_io _io/_iomodule.c _io/iobase.c _io/fileio.c _io/bytesio.c _io/bufferedio.c _io/textio.c _io/stringio.c _io/winconsoleio.c
 
 # The zipimport module is always imported at startup. Having it as a
 # builtin module avoids some bootstrapping problems and reduces overhead.
diff --git a/Modules/_ctypes/_ctypes.c b/Modules/_ctypes/_ctypes.c
index 1ced630..6e47f91 100644
--- a/Modules/_ctypes/_ctypes.c
+++ b/Modules/_ctypes/_ctypes.c
@@ -3171,11 +3171,28 @@ static PPROC FindAddress(void *handle, const char *name, PyObject *type)
     mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \0 _ @ %d */
     if (!mangled_name)
         return NULL;
+    /* Issue: for stdcall decorated export functions MSVC compiler adds
+     * underscore, but GCC compiler create them without. This is
+     * visible by example for _ctypes_test.pyd module.
+     * As well functions from system libraries are without underscore.
+     * Solutions:
+     * - If a python module is build with gcc option --add-stdcall-alias
+     * the module will contain XXX as alias for function XXX@ as result
+     * first search in this method will succeed.
+     * - Distutil may use compiler to create def-file, to modify it as
+     * add underscore alias and with new def file to create module.
+     * - Or may be just to search for function without underscore.
+     */
     for (i = 0; i < 32; ++i) {
         sprintf(mangled_name, "_%s@%d", name, i*4);
         address = (PPROC)GetProcAddress(handle, mangled_name);
         if (address)
             return address;
+        /* search for function without underscore as weel */
+        sprintf(mangled_name, "%s@%d", name, i*4);
+        address = (PPROC)GetProcAddress(handle, mangled_name);
+        if (address)
+            return address;
     }
     return NULL;
 #endif
diff --git a/Modules/_ctypes/callproc.c b/Modules/_ctypes/callproc.c
index ff95dff..0d41898 100644
--- a/Modules/_ctypes/callproc.c
+++ b/Modules/_ctypes/callproc.c
@@ -725,6 +725,21 @@ ffi_type *_ctypes_get_ffi_type(PyObject *obj)
 }
 
 
+#undef USE_PYFFI_DELTA
+#ifdef MS_WIN32
+#ifdef X86_ANY
+/* NOTE:
+ * - Standard library does not calculate stack pointer difference
+ *   unlike python specific for MSVC source.
+ * - As X86_ANY is defined in standard libffi only we will use as flag
+ *   to distinguish between standard and customized sources.
+ */
+#else
+/* use customized python libffi source */
+#  define USE_PYFFI_DELTA
+#endif
+#endif
+
 /*
  * libffi uses:
  *
@@ -753,7 +768,9 @@ static int _call_function_pointer(int flags,
     ffi_cif cif;
     int cc;
 #ifdef MS_WIN32
+#ifdef USE_PYFFI_DELTA
     int delta;
+#endif /* USE_PYFFI_DELTA */
 #ifndef DONT_USE_SEH
     DWORD dwExceptionCode = 0;
     EXCEPTION_RECORD record;
@@ -804,7 +821,9 @@ static int _call_function_pointer(int flags,
 #ifndef DONT_USE_SEH
     __try {
 #endif
+#ifdef USE_PYFFI_DELTA
         delta =
+#endif /* USE_PYFFI_DELTA */
 #endif
                 ffi_call(&cif, (void *)pProc, resmem, avalues);
 #ifdef MS_WIN32
@@ -838,6 +857,7 @@ static int _call_function_pointer(int flags,
         return -1;
     }
 #endif
+#ifdef USE_PYFFI_DELTA
 #ifdef MS_WIN64
     if (delta != 0) {
         PyErr_Format(PyExc_RuntimeError,
@@ -867,6 +887,7 @@ static int _call_function_pointer(int flags,
         return -1;
     }
 #endif
+#endif /* USE_PYFFI_DELTA */
 #endif
     if ((flags & FUNCFLAG_PYTHONAPI) && PyErr_Occurred())
         return -1;
diff --git a/Modules/_ctypes/libffi/fficonfig.py.in b/Modules/_ctypes/libffi/fficonfig.py.in
index d102498..0277c64 100644
--- a/Modules/_ctypes/libffi/fficonfig.py.in
+++ b/Modules/_ctypes/libffi/fficonfig.py.in
@@ -23,6 +23,7 @@ ffi_platforms = {
     'FRV': ['src/frv/eabi.S', 'src/frv/ffi.c'],
     'S390': ['src/s390/sysv.S', 'src/s390/ffi.c'],
     'X86_64': ['src/x86/ffi64.c', 'src/x86/unix64.S', 'src/x86/ffi.c', 'src/x86/sysv.S'],
+    'X86_WIN64': ['src/x86/ffi.c', 'src/x86/win64.S'],
     'SH': ['src/sh/sysv.S', 'src/sh/ffi.c'],
     'SH64': ['src/sh64/sysv.S', 'src/sh64/ffi.c'],
     'PA': ['src/pa/linux.S', 'src/pa/ffi.c'],
@@ -30,6 +31,9 @@ ffi_platforms = {
     'PA_HPUX': ['src/pa/hpux32.S', 'src/pa/ffi.c'],
 }
 
+ffi_target = '@TARGET@'
+if ffi_target not in ['X86_WIN32', 'X86_WIN64']:
+    ffi_sources += 'src/dlmalloc.c'
 ffi_sources += ffi_platforms['@TARGET@']
 
 ffi_cflags = '@CFLAGS@'
diff --git a/Modules/_cursesmodule.c b/Modules/_cursesmodule.c
index 7a70951..dba10c1 100644
--- a/Modules/_cursesmodule.c
+++ b/Modules/_cursesmodule.c
@@ -125,6 +125,10 @@ extern int setupterm(char *,int,int *);
 #include <langinfo.h>
 #endif
 
+#ifdef __MINGW32__
+#include <windows.h>
+#endif
+
 #if !defined(HAVE_NCURSES_H) && (defined(sgi) || defined(__sun) || defined(SCO5))
 #define STRICT_SYSV_CURSES       /* Don't use ncurses extensions */
 typedef chtype attr_t;           /* No attr_t type is available */
@@ -1735,10 +1739,14 @@ PyCursesWindow_PutWin(PyCursesWindowObject *self, PyObject *stream)
     /* We have to simulate this by writing to a temporary FILE*,
        then reading back, then writing to the argument stream. */
     char fn[100];
+#ifndef MS_WINDOWS
     int fd = -1;
+#endif
     FILE *fp = NULL;
     PyObject *res = NULL;
 
+#ifndef MS_WINDOWS
+/* Even on unix /tmp may not exist and the program must prefer $TMPDIR ! */
     strcpy(fn, "/tmp/py.curses.putwin.XXXXXX");
     fd = mkstemp(fn);
     if (fd < 0)
@@ -1746,6 +1754,14 @@ PyCursesWindow_PutWin(PyCursesWindowObject *self, PyObject *stream)
     if (_Py_set_inheritable(fd, 0, NULL) < 0)
         goto exit;
     fp = fdopen(fd, "wb+");
+#else
+    strcpy(fn, "py.curses.putwin.XXXXXX");
+    _mktemp(fn);
+    if (*fn == 0)
+        return PyErr_SetFromErrnoWithFilename(PyExc_IOError, fn);
+    fp = fopen(fn, "wb+");
+#endif
+
     if (fp == NULL) {
         PyErr_SetFromErrnoWithFilename(PyExc_IOError, fn);
         goto exit;
@@ -1770,8 +1786,10 @@ PyCursesWindow_PutWin(PyCursesWindowObject *self, PyObject *stream)
 exit:
     if (fp != NULL)
         fclose(fp);
+    #ifndef MS_WINDOWS
     else if (fd != -1)
         close(fd);
+    #endif
     remove(fn);
     return res;
 }
@@ -2294,7 +2312,9 @@ static PyObject *
 PyCurses_GetWin(PyCursesWindowObject *self, PyObject *stream)
 {
     char fn[100];
+#ifndef MS_WINDOWS
     int fd = -1;
+#endif
     FILE *fp = NULL;
     PyObject *data;
     size_t datalen;
@@ -2304,6 +2324,8 @@ PyCurses_GetWin(PyCursesWindowObject *self, PyObject *stream)
 
     PyCursesInitialised;
 
+#ifndef MS_WINDOWS
+/* Even on unix /tmp may not exist and the program must prefer $TMPDIR ! */
     strcpy(fn, "/tmp/py.curses.getwin.XXXXXX");
     fd = mkstemp(fn);
     if (fd < 0)
@@ -2311,6 +2333,13 @@ PyCurses_GetWin(PyCursesWindowObject *self, PyObject *stream)
     if (_Py_set_inheritable(fd, 0, NULL) < 0)
         goto error;
     fp = fdopen(fd, "wb+");
+#else
+    strcpy(fn, "py.curses.getwin.XXXXXX");
+    _mktemp(fn);
+    if (*fn == 0)
+        return PyErr_SetFromErrnoWithFilename(PyExc_IOError, fn);
+    fp = fopen(fn, "wb+");
+#endif
     if (fp == NULL) {
         PyErr_SetFromErrnoWithFilename(PyExc_IOError, fn);
         goto error;
@@ -2345,8 +2374,10 @@ PyCurses_GetWin(PyCursesWindowObject *self, PyObject *stream)
 error:
     if (fp != NULL)
         fclose(fp);
+    #ifndef MS_WINDOWS
     else if (fd != -1)
         close(fd);
+    #endif
     remove(fn);
     return res;
 }
diff --git a/Modules/_gdbmmodule.c b/Modules/_gdbmmodule.c
index daae71d..356cd0f 100644
--- a/Modules/_gdbmmodule.c
+++ b/Modules/_gdbmmodule.c
@@ -11,7 +11,7 @@
 #include <fcntl.h>
 #include "gdbm.h"
 
-#if defined(WIN32) && !defined(__CYGWIN__)
+#if defined(WIN32) && !defined(__CYGWIN__) && !defined(__MINGW32__)
 #include "gdbmerrno.h"
 extern const char * gdbm_strerror(gdbm_error);
 #endif
diff --git a/Modules/_io/_iomodule.c b/Modules/_io/_iomodule.c
index f4d3cbd..4cc7b50 100644
--- a/Modules/_io/_iomodule.c
+++ b/Modules/_io/_iomodule.c
@@ -20,7 +20,7 @@
 #include <sys/stat.h>
 #endif /* HAVE_SYS_STAT_H */
 
-#ifdef MS_WINDOWS
+#if defined(MS_WINDOWS) && !defined(__MINGW32__)
 #include <consoleapi.h>
 #endif
 
diff --git a/Modules/_io/fileio.c b/Modules/_io/fileio.c
index 918fa57..708294d 100644
--- a/Modules/_io/fileio.c
+++ b/Modules/_io/fileio.c
@@ -17,6 +17,7 @@
 #endif
 #include <stddef.h> /* For offsetof */
 #include "_iomodule.h"
+#include "iscygpty.h"
 
 /*
  * Known likely problems:
@@ -1115,7 +1116,7 @@ _io_FileIO_isatty_impl(fileio *self)
         return err_closed();
     Py_BEGIN_ALLOW_THREADS
     _Py_BEGIN_SUPPRESS_IPH
-    res = isatty(self->fd);
+    res = isatty(self->fd) || is_cygpty(self->fd);
     _Py_END_SUPPRESS_IPH
     Py_END_ALLOW_THREADS
     return PyBool_FromLong(res);
diff --git a/Modules/_localemodule.c b/Modules/_localemodule.c
index 71c9146..8a58603 100644
--- a/Modules/_localemodule.c
+++ b/Modules/_localemodule.c
@@ -11,6 +11,13 @@ This software comes with no warranty. Use at your own risk.
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
+#ifdef __MINGW32__
+/* The header libintl.h and library libintl may exist on mingw host.
+ * To be compatible with MSVC build we has to undef some defines.
+ */
+#undef HAVE_LIBINTL_H
+#undef HAVE_BIND_TEXTDOMAIN_CODESET
+#endif
 
 #include <stdio.h>
 #include <locale.h>
diff --git a/Modules/_multiprocessing/multiprocessing.c b/Modules/_multiprocessing/multiprocessing.c
index d92a8bf..b2db621 100644
--- a/Modules/_multiprocessing/multiprocessing.c
+++ b/Modules/_multiprocessing/multiprocessing.c
@@ -128,7 +128,7 @@ static PyMethodDef module_methods[] = {
     {"recv", multiprocessing_recv, METH_VARARGS, ""},
     {"send", multiprocessing_send, METH_VARARGS, ""},
 #endif
-#if !defined(POSIX_SEMAPHORES_NOT_ENABLED) && !defined(__ANDROID__)
+#if defined(MS_WINDOWS) || (!defined(POSIX_SEMAPHORES_NOT_ENABLED) && !defined(__ANDROID__))
     {"sem_unlink", _PyMp_sem_unlink, METH_VARARGS, ""},
 #endif
     {NULL}
diff --git a/Modules/_winapi.c b/Modules/_winapi.c
index b98e778..73e3410 100644
--- a/Modules/_winapi.c
+++ b/Modules/_winapi.c
@@ -39,7 +39,9 @@
 
 #define WINDOWS_LEAN_AND_MEAN
 #include "windows.h"
+#if defined(Py_DEBUG)
 #include <crtdbg.h>
+#endif
 #include "winreparse.h"
 
 #if defined(MS_WIN32) && !defined(MS_WIN64)
diff --git a/Modules/getpath.c b/Modules/getpath.c
index 0f91643..0318a23 100644
--- a/Modules/getpath.c
+++ b/Modules/getpath.c
@@ -10,6 +10,10 @@
 #include <mach-o/dyld.h>
 #endif
 
+#ifdef MS_WINDOWS
+#include <windows.h>
+#endif
+
 /* Search in some common locations for the associated Python libraries.
  *
  * Two directories must be found, the platform independent directory
@@ -109,9 +113,17 @@
 #define LANDMARK L"os.py"
 #endif
 
+#ifdef __MINGW32__
+#define wcstok(line, delim, pointer)  wcstok(line, delim)
+#endif
+
 static wchar_t prefix[MAXPATHLEN+1];
 static wchar_t exec_prefix[MAXPATHLEN+1];
 static wchar_t progpath[MAXPATHLEN+1];
+#ifdef MS_WINDOWS
+static wchar_t dllpath[MAXPATHLEN+1];
+extern HANDLE PyWin_DLLhModule;
+#endif
 static wchar_t *module_search_path = NULL;
 
 /* Get file status. Encode the path to the locale encoding. */
@@ -135,9 +147,9 @@ static void
 reduce(wchar_t *dir)
 {
     size_t i = wcslen(dir);
-    while (i > 0 && dir[i] != SEP)
+    while (i > 0 && dir[i] != Py_GetSepW(dir))
         --i;
-    dir[i] = '\0';
+    dir[i] = 0;
 }
 
 static int
@@ -207,12 +219,12 @@ static void
 joinpath(wchar_t *buffer, wchar_t *stuff)
 {
     size_t n, k;
-    if (stuff[0] == SEP)
+    if (stuff[0] == Py_GetSepW(buffer))
         n = 0;
     else {
         n = wcslen(buffer);
-        if (n > 0 && buffer[n-1] != SEP && n < MAXPATHLEN)
-            buffer[n++] = SEP;
+        if (n > 0 && buffer[n-1] != Py_GetSepW(buffer) && n < MAXPATHLEN)
+            buffer[n++] = Py_GetSepW(buffer);
     }
     if (n > MAXPATHLEN)
         Py_FatalError("buffer overflow in getpath.c's joinpath()");
@@ -228,7 +240,7 @@ joinpath(wchar_t *buffer, wchar_t *stuff)
 static void
 copy_absolute(wchar_t *path, wchar_t *p, size_t pathlen)
 {
-    if (p[0] == SEP)
+    if (p[0] == Py_GetSepW(p) || (p[0] != 0 && p[1] == L':'))
         wcscpy(path, p);
     else {
         if (!_Py_wgetcwd(path, pathlen)) {
@@ -236,7 +248,7 @@ copy_absolute(wchar_t *path, wchar_t *p, size_t pathlen)
             wcscpy(path, p);
             return;
         }
-        if (p[0] == '.' && p[1] == SEP)
+        if (p[0] == '.' && p[1] == Py_GetSepW(path))
             p += 2;
         joinpath(path, p);
     }
@@ -248,7 +260,7 @@ absolutize(wchar_t *path)
 {
     wchar_t buffer[MAXPATHLEN+1];
 
-    if (path[0] == SEP)
+    if (path[0] == Py_GetSepW(path))
         return;
     copy_absolute(buffer, path, MAXPATHLEN+1);
     wcscpy(path, buffer);
@@ -455,13 +467,33 @@ search_for_exec_prefix(wchar_t *argv0_path, wchar_t *home,
     return 0;
 }
 
+#ifdef MS_WINDOWS
+/* Calculates dllpath and progpath, replacing \\ with / */
+int GetWindowsModulePaths()
+{
+    int result = 0;
+    result = GetModuleFileNameW(NULL, progpath, MAXPATHLEN);
+    Py_NormalizeSepsW(progpath);
+    dllpath[0] = 0;
+#ifdef Py_ENABLE_SHARED
+    if (PyWin_DLLhModule) {
+        if((GetModuleFileNameW(PyWin_DLLhModule, dllpath, MAXPATHLEN) > 0)) {
+            result = 1;
+            Py_NormalizeSepsW(dllpath);
+        }
+    }
+#endif
+    return result;
+}
+#endif /* MS_WINDOWS */
+
 static void
 calculate_path(void)
 {
     extern wchar_t *Py_GetProgramName(void);
 
     static const wchar_t delimiter[2] = {DELIM, '\0'};
-    static const wchar_t separator[2] = {SEP, '\0'};
+    const wchar_t separator[2] = {Py_GetSepW(NULL), '\0'};
     char *_rtpypath = Py_GETENV("PYTHONPATH"); /* XXX use wide version on Windows */
     wchar_t *rtpypath = NULL;
     wchar_t *home = Py_GetPythonHome();
@@ -490,11 +522,12 @@ calculate_path(void)
 #endif
     wchar_t *_pythonpath, *_prefix, *_exec_prefix;
     wchar_t *lib_python;
+    const char * lib_python_VERSION = (Py_GetSepA(NULL) == '/') ? "lib/python" VERSION : "lib\\python" VERSION;
 
     _pythonpath = Py_DecodeLocale(PYTHONPATH, NULL);
     _prefix = Py_DecodeLocale(PREFIX, NULL);
     _exec_prefix = Py_DecodeLocale(EXEC_PREFIX, NULL);
-    lib_python = Py_DecodeLocale("lib/python" VERSION, NULL);
+    lib_python = Py_DecodeLocale(lib_python_VERSION, NULL);
 
     if (!_pythonpath || !_prefix || !_exec_prefix || !lib_python) {
         Py_FatalError(
@@ -512,7 +545,7 @@ calculate_path(void)
      * other way to find a directory to start the search from.  If
      * $PATH isn't exported, you lose.
      */
-    if (wcschr(prog, SEP))
+    if (wcschr(prog, Py_GetSepW(prog)))
         wcsncpy(progpath, prog, MAXPATHLEN);
 #ifdef __APPLE__
      /* On Mac OS X, if a script uses an interpreter of the form
@@ -533,6 +566,10 @@ calculate_path(void)
         }
     }
 #endif /* __APPLE__ */
+#ifdef MS_WINDOWS
+    else if(GetWindowsModulePaths()) {
+    }
+#endif /* MS_WINDOWS */
     else if (path) {
         while (1) {
             wchar_t *delim = wcschr(path, DELIM);
@@ -561,7 +598,7 @@ calculate_path(void)
     else
         progpath[0] = '\0';
     PyMem_RawFree(path_buffer);
-    if (progpath[0] != SEP && progpath[0] != '\0')
+    if (progpath[0] != separator[0] && progpath[0] != '\0' && progpath[1] != L':' )
         absolutize(progpath);
     wcsncpy(argv0_path, progpath, MAXPATHLEN);
     argv0_path[MAXPATHLEN] = '\0';
@@ -719,7 +756,7 @@ calculate_path(void)
     while (1) {
         wchar_t *delim = wcschr(defpath, DELIM);
 
-        if (defpath[0] != SEP)
+        if (defpath[0] != separator[0] && defpath[0] != '\0' && defpath[1] != L':')
             /* Paths are relative to prefix */
             bufsz += prefixsz;
 
@@ -734,7 +771,10 @@ calculate_path(void)
 
     bufsz += wcslen(zip_path) + 1;
     bufsz += wcslen(exec_prefix) + 1;
-
+#ifdef MS_WINDOWS
+    if (_exec_prefix)
+        bufsz += wcslen(_exec_prefix) + 1;
+#endif
     buf = PyMem_New(wchar_t, bufsz);
     if (buf == NULL) {
         Py_FatalError(
@@ -760,7 +800,7 @@ calculate_path(void)
     while (1) {
         wchar_t *delim = wcschr(defpath, DELIM);
 
-        if (defpath[0] != SEP) {
+        if (defpath[0] != separator[0] && defpath[0] != '\0' && defpath[1] != L':') {
             wcscat(buf, prefix);
             if (prefixsz >= 2 && prefix[prefixsz - 2] != SEP &&
                 defpath[0] != (delim ? DELIM : L'\0')) {  /* not empty */
@@ -813,7 +853,40 @@ calculate_path(void)
     }
     else
         wcsncpy(exec_prefix, _exec_prefix, MAXPATHLEN);
+#ifdef MS_WINDOWS
+    if (_exec_prefix) {
+        /* Next add bin folder where the exe was found, for System DLLs e.g. tcl86.dll, tk86.dll */
+        wcscat(buf, delimiter);
+        wcscat(buf, _exec_prefix);
+      }
+#endif
 
+#ifdef MS_WINDOWS
+    if (_path) {
+        wchar_t *module_path, *new_path;
+        /* Add path of executable/dll to system path. This
+         * is so that the correct tcl??.dll and tk??.dll get used. */
+        path_buffer = Py_DecodeLocale(_path, NULL);
+        module_path = dllpath[0] ? dllpath : progpath;
+        new_path = (wchar_t *)alloca(sizeof(wchar_t)*(wcslen(L"PATH=")+wcslen(module_path)+1+wcslen(path_buffer)+1));
+        if (new_path) {
+            wchar_t *slashes, *end;
+            wcscpy(new_path, L"PATH=");
+            wcscat(new_path, module_path);
+            slashes = wcschr(new_path, L'/');
+            while (slashes) {
+                *slashes = L'\\';
+                slashes = wcschr( slashes+1, L'/' );
+            }
+            end = wcsrchr(new_path, L'\\') ? wcsrchr(new_path, L'\\') : new_path + wcslen(new_path);
+            end[0] = L';';
+            end[1] = L'\0';
+            wcscat(new_path, path_buffer);
+            _wputenv(new_path);
+            PyMem_RawFree(path_buffer);
+        }
+    }
+#endif
     PyMem_RawFree(_pythonpath);
     PyMem_RawFree(_prefix);
     PyMem_RawFree(_exec_prefix);
@@ -874,6 +947,57 @@ Py_GetProgramFullPath(void)
 }
 
 
+#ifdef MS_WINDOWS
+/* Load python3.dll before loading any extension module that might refer
+   to it. That way, we can be sure that always the python3.dll corresponding
+   to this python DLL is loaded, not a python3.dll that might be on the path
+   by chance.
+   Return whether the DLL was found.
+*/
+static int python3_checked = 0;
+static HANDLE hPython3;
+int
+_Py_CheckPython3()
+{
+    /* This does not work well with mingw-w64-python. First it tries to
+     * look up \python3.dll, which it won't (or should not) find. But the
+     * real problem is when Python is freezed by cx_Freeze. sys.prefix
+     * is then /, and Python tries to load /\DLLs\python3.dll, which makes
+     * windows try to load python3.dll from a network address, causing
+     * a several seconds long delay before proceeding. Since this code does
+     * not do anything useful in the current state, we might just as
+     * well return immediately. */
+#ifdef __MINGW32__
+    return 0;
+#else
+    wchar_t py3path[MAXPATHLEN+1];
+    wchar_t *s;
+    if (python3_checked)
+        return hPython3 != NULL;
+    python3_checked = 1;
+
+    /* If there is a python3.dll next to the python3y.dll,
+       assume this is a build tree; use that DLL */
+    wcscpy(py3path, dllpath);
+    s = wcsrchr(py3path, Py_GetSepW(py3path));
+    if (!s)
+        s = py3path;
+    else
+        s += 1;
+    wcscpy(s, L"python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    if (hPython3 != NULL)
+        return 1;
+
+    /* Check sys.prefix\DLLs\python3.dll */
+    wcscpy(py3path, Py_GetPrefix());
+    wcscat(py3path, L"\\DLLs\\python3.dll");
+    hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
+    return hPython3 != NULL;
+#endif
+}
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/Modules/makesetup b/Modules/makesetup
index 8db8de8..d6f766e 100755
--- a/Modules/makesetup
+++ b/Modules/makesetup
@@ -92,7 +92,7 @@ CYGWIN*) if test $libdir = .
 	 else
 	 	ExtraLibDir='$(LIBPL)'
 	 fi
-	 ExtraLibs="-L$ExtraLibDir -lpython\$(VERSION)";;
+	 ExtraLibs="-L$ExtraLibDir -lpython\$(LDVERSION)";;
 esac
 
 # Main loop
diff --git a/Modules/parsermodule.c b/Modules/parsermodule.c
index a444335..5e74e20 100644
--- a/Modules/parsermodule.c
+++ b/Modules/parsermodule.c
@@ -42,7 +42,7 @@
 #undef Yield
 #include "ast.h"
 
-extern grammar _PyParser_Grammar; /* From graminit.c */
+PyAPI_DATA(grammar) _PyParser_Grammar; /* From graminit.c */
 
 #ifdef lint
 #include <note.h>
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index ee27fa4..6498181 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -31,6 +31,7 @@
 #else
 #include "winreparse.h"
 #endif
+#include "iscygpty.h"
 
 /* On android API level 21, 'AT_EACCESS' is not declared although
  * HAVE_FACCESSAT is defined. */
@@ -176,6 +177,26 @@ corresponding Unix manual entries for more information on calls.");
 #define HAVE_CWAIT      1
 #define HAVE_FSYNC      1
 #define fsync _commit
+#elif defined(__MINGW32__)	/* GCC for windows hosts */
+/* getlogin is detected by configure on mingw-w64 */
+#undef HAVE_GETLOGIN
+/*#define HAVE_GETCWD	1 - detected by configure*/
+#define HAVE_GETPPID    1
+#define HAVE_GETLOGIN   1
+#define HAVE_SPAWNV	1
+#define HAVE_WSPAWNV    1
+/*#define HAVE_EXECV	1 - detected by configure*/
+#define HAVE_PIPE	1
+#define HAVE_POPEN	1
+#define HAVE_SYSTEM	1
+#define HAVE_CWAIT	1
+#define HAVE_FSYNC	1
+#define fsync _commit
+#include <windows.h>
+#include <winioctl.h>
+#ifndef _MAX_ENV
+#define _MAX_ENV	32767
+#endif
 #else
 /* Unix functions that the configure script doesn't check for */
 #define HAVE_EXECV      1
@@ -296,7 +317,7 @@ extern int lstat(const char *, struct stat *);
 #endif
 #endif
 
-#ifdef _MSC_VER
+#ifdef MS_WINDOWS
 #ifdef HAVE_DIRECT_H
 #include <direct.h>
 #endif
@@ -1222,7 +1243,7 @@ win32_get_reparse_tag(HANDLE reparse_point_handle, ULONG *reparse_tag)
 */
 #include <crt_externs.h>
 static char **environ;
-#elif !defined(_MSC_VER) && ( !defined(__WATCOMC__) || defined(__QNX__) )
+#elif !defined(MS_WINDOWS) && ( !defined(__WATCOMC__) || defined(__QNX__) )
 extern char **environ;
 #endif /* !_MSC_VER */
 
@@ -1498,6 +1519,31 @@ attributes_from_dir(LPCWSTR pszFile, BY_HANDLE_FILE_INFORMATION *info, ULONG *re
     return TRUE;
 }
 
+/* Grab GetFinalPathNameByHandle dynamically from kernel32 */
+static int has_GetFinalPathNameByHandle = -1;
+static DWORD (CALLBACK *Py_GetFinalPathNameByHandleW)(HANDLE, LPWSTR, DWORD,
+                                                      DWORD);
+static int
+check_GetFinalPathNameByHandle()
+{
+    HINSTANCE hKernel32;
+    DWORD (CALLBACK *Py_GetFinalPathNameByHandleA)(HANDLE, LPSTR, DWORD,
+                                                   DWORD);
+
+    /* only recheck */
+    if (-1 == has_GetFinalPathNameByHandle)
+    {
+        hKernel32 = GetModuleHandleW(L"KERNEL32");
+        *(FARPROC*)&Py_GetFinalPathNameByHandleA = GetProcAddress(hKernel32,
+                                                "GetFinalPathNameByHandleA");
+        *(FARPROC*)&Py_GetFinalPathNameByHandleW = GetProcAddress(hKernel32,
+                                                "GetFinalPathNameByHandleW");
+        has_GetFinalPathNameByHandle = Py_GetFinalPathNameByHandleA &&
+                                       Py_GetFinalPathNameByHandleW;
+    }
+    return has_GetFinalPathNameByHandle;
+}
+
 static BOOL
 get_target_path(HANDLE hdl, wchar_t **target_path)
 {
@@ -1506,8 +1552,8 @@ get_target_path(HANDLE hdl, wchar_t **target_path)
 
     /* We have a good handle to the target, use it to determine
        the target path name (then we'll call lstat on it). */
-    buf_size = GetFinalPathNameByHandleW(hdl, 0, 0,
-                                         VOLUME_NAME_DOS);
+    buf_size = Py_GetFinalPathNameByHandleW(hdl, 0, 0,
+                                            VOLUME_NAME_DOS);
     if(!buf_size)
         return FALSE;
 
@@ -1517,7 +1563,7 @@ get_target_path(HANDLE hdl, wchar_t **target_path)
         return FALSE;
     }
 
-    result_length = GetFinalPathNameByHandleW(hdl,
+    result_length = Py_GetFinalPathNameByHandleW(hdl,
                        buf, buf_size, VOLUME_NAME_DOS);
 
     if(!result_length) {
@@ -1547,6 +1593,12 @@ win32_xstat_impl(const wchar_t *path, struct _Py_stat_struct *result,
     wchar_t *target_path;
     const wchar_t *dot;
 
+    if(!check_GetFinalPathNameByHandle()) {
+        /* If the OS doesn't have GetFinalPathNameByHandle, don't
+           traverse reparse point. */
+        traverse = FALSE;
+    }
+
     hFile = CreateFileW(
         path,
         FILE_READ_ATTRIBUTES, /* desired access */
@@ -3217,6 +3269,7 @@ posix_getcwd(int use_bytes)
                 PyMem_RawFree(wbuf2);
             return PyErr_SetFromWindowsErr(0);
         }
+        Py_NormalizeSepsW(wbuf2);
         resobj = PyUnicode_FromWideChar(wbuf2, len);
         if (wbuf2 != wbuf)
             PyMem_RawFree(wbuf2);
@@ -3454,7 +3507,7 @@ _listdir_windows_no_opendir(path_t *path, PyObject *list)
         Py_END_ALLOW_THREADS
         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
            it got to the end of the directory. */
-        if (!result && GetLastError() != ERROR_NO_MORE_FILES) {
+        if (!result && GetLastError() != 0 && GetLastError() != ERROR_NO_MORE_FILES) {
             Py_DECREF(list);
             list = path_error(path);
             goto exit;
@@ -3646,6 +3699,7 @@ os__getfullpathname_impl(PyObject *module, path_t *path)
         result = GetFullPathNameW(path->wide, result, woutbufp, &wtemp);
     }
     if (result) {
+        Py_NormalizeSepsW(woutbufp);
         v = PyUnicode_FromWideChar(woutbufp, wcslen(woutbufp));
         if (path->narrow)
             Py_SETREF(v, PyUnicode_EncodeFSDefault(v));
@@ -3681,6 +3735,13 @@ os__getfinalpathname_impl(PyObject *module, PyObject *path)
     if (path_wchar == NULL)
         return NULL;
 
+    if(!check_GetFinalPathNameByHandle()) {
+        /* If the OS doesn't have GetFinalPathNameByHandle, return a
+           NotImplementedError. */
+        return PyErr_Format(PyExc_NotImplementedError,
+            "GetFinalPathNameByHandle not available on this platform");
+    }
+
     hFile = CreateFileW(
         path_wchar,
         0, /* desired access */
@@ -3696,7 +3757,7 @@ os__getfinalpathname_impl(PyObject *module, PyObject *path)
 
     /* We have a good handle to the target, use it to determine the
        target path name. */
-    buf_size = GetFinalPathNameByHandleW(hFile, 0, 0, VOLUME_NAME_NT);
+    buf_size = Py_GetFinalPathNameByHandleW(hFile, 0, 0, VOLUME_NAME_NT);
 
     if(!buf_size)
         return win32_error_object("GetFinalPathNameByHandle", path);
@@ -3705,14 +3766,15 @@ os__getfinalpathname_impl(PyObject *module, PyObject *path)
     if(!target_path)
         return PyErr_NoMemory();
 
-    result_length = GetFinalPathNameByHandleW(hFile, target_path,
-                                              buf_size, VOLUME_NAME_DOS);
+    result_length = Py_GetFinalPathNameByHandleW(hFile, target_path,
+                                                 buf_size, VOLUME_NAME_DOS);
     if(!result_length)
         return win32_error_object("GetFinalPathNamyByHandle", path);
 
     if(!CloseHandle(hFile))
         return win32_error_object("CloseHandle", path);
 
+    Py_NormalizeSepsW(target_path);
     target_path[result_length] = 0;
     result = PyUnicode_FromWideChar(target_path, result_length);
     PyMem_Free(target_path);
@@ -8311,7 +8373,7 @@ os_isatty_impl(PyObject *module, int fd)
 {
     int return_value;
     _Py_BEGIN_SUPPRESS_IPH
-    return_value = isatty(fd);
+    return_value = isatty(fd) || is_cygpty(fd);
     _Py_END_SUPPRESS_IPH
     return return_value;
 }
diff --git a/Modules/readline.c b/Modules/readline.c
index 575479c..194911b 100644
--- a/Modules/readline.c
+++ b/Modules/readline.c
@@ -6,6 +6,7 @@
 
 /* Standard definitions */
 #include "Python.h"
+#include "iscygpty.h"
 #include <stddef.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -1406,6 +1407,11 @@ PyInit_readline(void)
     PyObject *m;
     readlinestate *mod_state;
 
+    if (!is_cygpty(STDOUT_FILENO)) {
+        PyErr_SetString(PyExc_ImportError, "Not a cygwin terminal");
+        return NULL;
+    }
+
 #ifdef __APPLE__
     if (strncmp(rl_library_version, libedit_version_tag, strlen(libedit_version_tag)) == 0) {
         using_libedit_emulation = 1;
diff --git a/Modules/selectmodule.c b/Modules/selectmodule.c
index 07a20c8..8a53f5d 100644
--- a/Modules/selectmodule.c
+++ b/Modules/selectmodule.c
@@ -106,9 +106,9 @@ seq2set(PyObject *seq, fd_set *set, pylist fd2obj[FD_SETSIZE + 1])
         v = PyObject_AsFileDescriptor( o );
         if (v == -1) goto finally;
 
-#if defined(_MSC_VER)
+#if defined(MS_WIN32)
         max = 0;                             /* not used for Win32 */
-#else  /* !_MSC_VER */
+#else  /* !MS_WIN32 */
         if (!_PyIsSelectable_fd(v)) {
             PyErr_SetString(PyExc_ValueError,
                         "filedescriptor out of range in select()");
@@ -116,7 +116,7 @@ seq2set(PyObject *seq, fd_set *set, pylist fd2obj[FD_SETSIZE + 1])
         }
         if (v > max)
             max = v;
-#endif /* _MSC_VER */
+#endif /* MS_WIN32 */
         FD_SET(v, set);
 
         /* add object and its file descriptor to the list */
diff --git a/Modules/socketmodule.c b/Modules/socketmodule.c
index a351faa..5d4bb39 100644
--- a/Modules/socketmodule.c
+++ b/Modules/socketmodule.c
@@ -335,6 +335,12 @@ http://cvsweb.netbsd.org/bsdweb.cgi/src/lib/libc/net/getaddrinfo.c.diff?r1=1.82&
   /* Do not include addrinfo.h for MSVC7 or greater. 'addrinfo' and
    * EAI_* constants are defined in (the already included) ws2tcpip.h.
    */
+#elif defined(__MINGW32__)
+  /* Do not include addrinfo.h as minimum supported version is
+   * _WIN32_WINNT >= WindowsXP(0x0501)
+   */
+#  define HAVE_GETADDRINFO
+#  define HAVE_GETNAMEINFO
 #else
 #  include "addrinfo.h"
 #endif
diff --git a/Modules/socketmodule.h b/Modules/socketmodule.h
index 03f982b..6310eb3 100644
--- a/Modules/socketmodule.h
+++ b/Modules/socketmodule.h
@@ -28,7 +28,7 @@
  * I use SIO_GET_MULTICAST_FILTER to detect a decent SDK.
  */
 # ifdef SIO_GET_MULTICAST_FILTER
-#  include <MSTcpIP.h> /* for SIO_RCVALL */
+#  include <mstcpip.h> /* for SIO_RCVALL */
 #  define HAVE_ADDRINFO
 #  define HAVE_SOCKADDR_STORAGE
 #  define HAVE_GETADDRINFO
diff --git a/PC/getpathp.c b/PC/getpathp.c
index e7be704..2206e76 100644
--- a/PC/getpathp.c
+++ b/PC/getpathp.c
@@ -112,11 +112,34 @@
  * with a semicolon separated path prior to calling Py_Initialize.
  */
 
+#ifndef PYTHONPATH
+#  define PYTHONPATH L".\\DLLs;.\\lib"
+#endif
+
 #ifndef LANDMARK
 #define LANDMARK L"lib\\os.py"
 #endif
 
+#ifdef __MINGW32__
+
+static wchar_t *lib_python = L"lib\\python" VERSION;
+
+#  undef LANDMARK
+#  define LANDMARK L"os.py"
+
+#  define USE_POSIX_PREFIX
+
+#  ifdef Py_ENABLE_SHARED
+#    define USE_EXEC_PREFIX
+#  endif
+
+#endif
+
+
 static wchar_t prefix[MAXPATHLEN+1];
+#ifdef USE_EXEC_PREFIX
+static wchar_t exec_prefix[MAXPATHLEN+1];
+#endif
 static wchar_t progpath[MAXPATHLEN+1];
 static wchar_t dllpath[MAXPATHLEN+1];
 static wchar_t *module_search_path = NULL;
@@ -241,6 +264,69 @@ join(wchar_t *buffer, const wchar_t *stuff)
     }
 }
 
+#ifdef USE_POSIX_PREFIX
+
+/* based on getpath.c but with paths relative to executable */
+/* search_for_prefix requires that path be no more than MAXPATHLEN
+   bytes long.
+   return: 1 if found; -1 if found build directory
+*/
+static int
+search_for_posix_prefix(wchar_t *argv0_path, wchar_t *home, wchar_t *_prefix)
+{
+    size_t n;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (home) {
+        wchar_t *delim;
+        wcsncpy(prefix, home, MAXPATHLEN);
+        delim = wcschr(prefix, DELIM);
+        if (delim)
+            *delim = L'\0';
+        join(prefix, lib_python);
+        join(prefix, LANDMARK);
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory */
+    wcscpy(prefix, argv0_path);
+    join(prefix, L"Modules\\Setup");
+    if (exists(prefix)) {
+        wchar_t *vpath;
+        /* Check source directory if argv0_path is in the build directory. */
+        vpath = Py_DecodeLocale(SRCDIR, NULL);
+        if (vpath != NULL) {
+            wcscpy(prefix, argv0_path);
+            join(prefix, vpath);
+            PyMem_Free(vpath);
+            join(prefix, L"Lib");
+            join(prefix, LANDMARK);
+            if (ismodule(prefix))
+                return -1;
+        }
+    }
+
+    /* Search from argv0_path, until root is found */
+    wcscpy(prefix, argv0_path);
+    do {
+        n = wcslen(prefix);
+        join(prefix, lib_python);
+        join(prefix, LANDMARK);
+        if (ismodule(prefix))
+            return 1;
+        prefix[n] = L'\0';
+        reduce(prefix);
+    } while (prefix[0]);
+
+    /* Configure prefix is unused */
+    (void)_prefix;
+
+    /* Fail */
+    return 0;
+}
+
+#endif /*def USE_POSIX_PREFIX */
+
 /* gotlandmark only called by search_for_prefix, which ensures
    'prefix' is null terminated in bounds.  join() ensures
    'landmark' can not overflow prefix if too long.
@@ -277,6 +363,82 @@ search_for_prefix(wchar_t *argv0_path, const wchar_t *landmark)
 /* a string loaded from the DLL at startup.*/
 extern const char *PyWin_DLLVersionString;
 
+#ifdef USE_EXEC_PREFIX
+
+/* based on getpath.c but with path relative to executabe */
+/* search_for exec_prefix requires that paths be no more than
+   MAXPATHLEN bytes long.
+   return: 1 if found; -1 if found build directory
+*/
+static int
+search_for_exec_prefix(wchar_t *argv0_path, wchar_t *home, wchar_t *_exec_prefix)
+{
+    size_t n;
+
+    /* If PYTHONHOME is set, we believe it unconditionally */
+    if (home) {
+        wchar_t *delim;
+        delim = wcschr(home, DELIM);
+        if (delim)
+            wcsncpy(exec_prefix, delim+1, MAXPATHLEN);
+        else
+            wcsncpy(exec_prefix, home, MAXPATHLEN);
+        join(exec_prefix, lib_python);
+        join(exec_prefix, L"lib-dynload");
+        return 1;
+    }
+
+    /* Check to see if argv[0] is in the build directory. "pybuilddir.txt"
+       is written by setup.py and contains the relative path to the location
+       of shared library modules. */
+    wcscpy(exec_prefix, argv0_path);
+    join(exec_prefix, L"pybuilddir.txt");
+    if (exists(exec_prefix)) {
+        FILE *f = _Py_wfopen(exec_prefix, L"rb");
+        if (f == NULL)
+            errno = 0;
+        else {
+            char buf[MAXPATHLEN+1];
+            PyObject *decoded;
+            wchar_t rel_builddir_path[MAXPATHLEN+1];
+            n = fread(buf, 1, MAXPATHLEN, f);
+            buf[n] = '\0';
+            fclose(f);
+            decoded = PyUnicode_DecodeMBCS(buf, n, NULL);
+            if (decoded != NULL) {
+                Py_ssize_t k;
+                k = PyUnicode_AsWideChar(decoded,
+                                         rel_builddir_path, MAXPATHLEN);
+                Py_DECREF(decoded);
+                if (k >= 0) {
+                    rel_builddir_path[k] = L'\0';
+                    wcscpy(exec_prefix, argv0_path);
+                    join(exec_prefix, rel_builddir_path);
+                    return -1;
+                }
+            }
+        }
+    }
+
+    /* Search from argv0_path, until root is found */
+    wcscpy(exec_prefix, argv0_path);
+    do {
+        n = wcslen(exec_prefix);
+        join(exec_prefix, lib_python);
+        join(exec_prefix, L"lib-dynload");
+        if (exists(exec_prefix))
+            return 1;
+        exec_prefix[n] = L'\0';
+        reduce(exec_prefix);
+    } while (exec_prefix[0]);
+
+    /* Configure exec_prefix is unused */
+    (void)_exec_prefix;
+
+    /* Fail */
+    return 0;
+}
+#endif /*def USE_EXEC_PREFIX*/
 
 /* Load a PYTHONPATH value from the registry.
    Load from either HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER.
@@ -631,6 +793,12 @@ calculate_path(void)
     size_t bufsz;
     wchar_t *pythonhome = Py_GetPythonHome();
     wchar_t *envpath = NULL;
+#ifdef USE_POSIX_PREFIX
+    int pfound;
+#endif
+#ifdef USE_EXEC_PREFIX
+    int efound;
+#endif
 
     int skiphome, skipdefault;
     wchar_t *machinepath = NULL;
@@ -696,6 +864,16 @@ calculate_path(void)
     /* Calculate zip archive path from DLL or exe path */
     change_ext(zip_path, dllpath[0] ? dllpath : progpath, L".zip");
 
+#ifdef USE_POSIX_PREFIX
+    pfound = search_for_posix_prefix(argv0_path, pythonhome, NULL);
+    if (!pfound) {
+        wcsncpy(prefix, argv0_path, MAXPATHLEN);
+        reduce(prefix);
+        join(prefix, lib_python);
+    }
+    else
+        reduce(prefix);
+#else
     if (pythonhome == NULL || *pythonhome == '\0') {
         if (zip_path[0] && exists(zip_path)) {
             wcscpy_s(prefix, MAXPATHLEN+1, zip_path);
@@ -708,10 +886,20 @@ calculate_path(void)
     }
     else
         wcscpy_s(prefix, MAXPATHLEN+1, pythonhome);
+#endif
 
     if (envpath && *envpath == '\0')
         envpath = NULL;
 
+#ifdef USE_EXEC_PREFIX
+    efound = search_for_exec_prefix(argv0_path, pythonhome, NULL);
+    if (!efound) {
+        wcsncpy(exec_prefix, argv0_path, MAXPATHLEN);
+        reduce(exec_prefix);
+        join(exec_prefix, lib_python);
+        join(exec_prefix, L"lib-dynload");
+    }
+#endif
 
     skiphome = pythonhome==NULL ? 0 : 1;
 #ifdef Py_ENABLE_SHARED
@@ -748,6 +936,12 @@ calculate_path(void)
     }
     else
         bufsz = 0;
+#ifdef USE_POSIX_PREFIX
+    bufsz += wcslen(prefix) + 1;
+#endif
+#ifdef USE_EXEC_PREFIX
+    bufsz += wcslen(exec_prefix) + 1;
+#endif
     bufsz += wcslen(PYTHONPATH) + 1;
     bufsz += wcslen(argv0_path) + 1;
     if (userpath)
@@ -787,6 +981,16 @@ calculate_path(void)
         buf = wcschr(buf, L'\0');
         *buf++ = DELIM;
     }
+#ifdef USE_POSIX_PREFIX
+    wcscpy(buf, prefix);
+    buf = wcschr(buf, L'\0');
+    *buf++ = DELIM;
+#endif
+#ifdef USE_EXEC_PREFIX
+    wcscpy(buf, exec_prefix);
+    buf = wcschr(buf, L'\0');
+    *buf++ = DELIM;
+#endif
     if (userpath) {
         if (wcscpy_s(buf, bufsz - (buf - module_search_path), userpath))
             Py_FatalError("buffer overflow in getpathp.c's calculate_path()");
@@ -847,6 +1051,23 @@ calculate_path(void)
        on the path, and that our 'prefix' directory is
        the parent of that.
     */
+#ifdef USE_POSIX_PREFIX
+    if (pfound > 0) {
+        reduce(prefix);
+        reduce(prefix);
+    }
+    else
+        wcscpy(prefix, argv0_path);
+#endif
+#ifdef USE_EXEC_PREFIX
+    if (efound > 0) {
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+        reduce(exec_prefix);
+    }
+    else
+        wcscpy(exec_prefix, argv0_path);
+#endif
     if (*prefix==L'\0') {
         wchar_t lookBuf[MAXPATHLEN+1];
         wchar_t *look = buf - 1; /* 'buf' is at the end of the buffer */
@@ -915,7 +1136,13 @@ Py_GetPrefix(void)
 wchar_t *
 Py_GetExecPrefix(void)
 {
+#ifdef USE_EXEC_PREFIX
+    if (!module_search_path)
+        calculate_path();
+    return exec_prefix;
+#else
     return Py_GetPrefix();
+#endif
 }
 
 wchar_t *
diff --git a/PC/msvcrtmodule.c b/PC/msvcrtmodule.c
index 4797cdc..410f708 100644
--- a/PC/msvcrtmodule.c
+++ b/PC/msvcrtmodule.c
@@ -21,7 +21,9 @@
 #include <io.h>
 #include <conio.h>
 #include <sys/locking.h>
+#ifdef _DEBUG
 #include <crtdbg.h>
+#endif
 #include <windows.h>
 
 #ifdef _MSC_VER
diff --git a/PC/winreg.c b/PC/winreg.c
index 5efdc5e..3efe8ae 100644
--- a/PC/winreg.c
+++ b/PC/winreg.c
@@ -16,6 +16,25 @@
 #include "structmember.h"
 #include "windows.h"
 
+#ifndef SIZEOF_HKEY
+/* used only here */
+#if defined(MS_WIN64)
+#  define SIZEOF_HKEY 8
+#elif defined(MS_WIN32)
+#  define SIZEOF_HKEY 4
+#else
+#  error "SIZEOF_HKEY is not defined"
+#endif
+#endif
+
+#ifndef REG_LEGAL_CHANGE_FILTER
+#define REG_LEGAL_CHANGE_FILTER        (\
+          REG_NOTIFY_CHANGE_NAME       |\
+          REG_NOTIFY_CHANGE_ATTRIBUTES |\
+          REG_NOTIFY_CHANGE_LAST_SET   |\
+          REG_NOTIFY_CHANGE_SECURITY   )
+#endif
+
 static BOOL PyHKEY_AsHKEY(PyObject *ob, HKEY *pRes, BOOL bNoneOK);
 static BOOL clinic_HKEY_converter(PyObject *ob, void *p);
 static PyObject *PyHKEY_FromHKEY(HKEY h);
diff --git a/Parser/metagrammar.c b/Parser/metagrammar.c
index 53810b8..8343b87 100644
--- a/Parser/metagrammar.c
+++ b/Parser/metagrammar.c
@@ -139,7 +139,7 @@ static label labels[19] = {
     {7, 0},
     {8, 0},
 };
-static grammar _PyParser_Grammar = {
+static grammar _PyParser_MetaGrammar = {
     6,
     dfas,
     {19, labels},
@@ -149,7 +149,7 @@ static grammar _PyParser_Grammar = {
 grammar *
 meta_grammar(void)
 {
-    return &_PyParser_Grammar;
+    return &_PyParser_MetaGrammar;
 }
 
 grammar *
diff --git a/Programs/_freeze_importlib.c b/Programs/_freeze_importlib.c
index 1069966..b421e0e 100644
--- a/Programs/_freeze_importlib.c
+++ b/Programs/_freeze_importlib.c
@@ -20,7 +20,7 @@ static const struct _frozen _PyImport_FrozenModules[] = {
     {0, 0, 0} /* sentinel */
 };
 
-#ifndef MS_WINDOWS
+#ifndef _MSC_VER
 /* On Windows, this links with the regular pythonXY.dll, so this variable comes
    from frozen.obj. In the Makefile, frozen.o is not linked into this executable,
    so we define the variable here. */
diff --git a/Programs/python.c b/Programs/python.c
index a7afbc7..7b8fb83 100644
--- a/Programs/python.c
+++ b/Programs/python.c
@@ -7,7 +7,7 @@
 #include <fenv.h>
 #endif
 
-#ifdef MS_WINDOWS
+#if defined(_MSC_VER)
 int
 wmain(int argc, wchar_t **argv)
 {
diff --git a/Python/condvar.h b/Python/condvar.h
index 9a71b17..24b050a 100644
--- a/Python/condvar.h
+++ b/Python/condvar.h
@@ -42,6 +42,12 @@
 
 #include "Python.h"
 
+#ifdef __MINGW32__
+# if !defined(HAVE_PTHREAD_H) || defined(NT_THREADS)
+#  undef _POSIX_THREADS
+# endif
+#endif
+
 #ifndef _POSIX_THREADS
 /* This means pthreads are not implemented in libc headers, hence the macro
    not present in unistd.h. But they still can be implemented as an external
diff --git a/Python/dynload_win.c b/Python/dynload_win.c
index 0fdf77f..79aa5b2 100644
--- a/Python/dynload_win.c
+++ b/Python/dynload_win.c
@@ -33,11 +33,21 @@ void _Py_DeactivateActCtx(ULONG_PTR cookie);
 #define PYD_UNTAGGED_SUFFIX PYD_DEBUG_SUFFIX ".pyd"
 
 const char *_PyImport_DynLoadFiletab[] = {
+#ifdef EXT_SUFFIX
+    EXT_SUFFIX, /* include SOABI flags where is encoded debug */
+#endif
+#ifdef SHLIB_SUFFIX
+    "-abi" PYTHON_ABI_STRING SHLIB_SUFFIX,
+#endif
     PYD_TAGGED_SUFFIX,
     PYD_UNTAGGED_SUFFIX,
     NULL
 };
 
+#if defined(__MINGW32__)
+/* avoid compile error: conflicting types for 'strcasecmp' */
+#  define strcasecmp fake_strcasecmp
+#endif
 /* Case insensitive string compare, to avoid any dependencies on particular
    C RTL implementations */
 
diff --git a/Python/fileblocks.c b/Python/fileblocks.c
new file mode 100644
index 0000000..a869239
--- /dev/null
+++ b/Python/fileblocks.c
@@ -0,0 +1,17 @@
+/*
+-- Macro: AC_STRUCT_ST_BLOCKS
+    If 'struct stat' contains an 'st_blocks' member, define
+    'HAVE_STRUCT_STAT_ST_BLOCKS'.  Otherwise, require an 'AC_LIBOBJ'
+    replacement of 'fileblocks'.
+*/
+
+#if !HAVE_STRUCT_STAT_ST_BLOCKS
+/* If necessary you may see gnulib for replacement function:
+ * off_t st_blocks (off_t size).
+ * You may found code available under GPL2 or GPL3.
+ */
+
+/* This declaration is solely to ensure that after preprocessing
+   this file is never empty. */
+typedef int textutils_fileblocks_unused;
+#endif
diff --git a/Python/frozenmain.c b/Python/frozenmain.c
index 769b33d..ca04c50 100644
--- a/Python/frozenmain.c
+++ b/Python/frozenmain.c
@@ -3,6 +3,7 @@
 
 #include "Python.h"
 #include <locale.h>
+#include "iscygpty.h"
 
 #ifdef MS_WINDOWS
 extern void PyWinFreeze_ExeInit(void);
@@ -93,7 +94,7 @@ Py_FrozenMain(int argc, char **argv)
     else
         sts = 0;
 
-    if (inspect && isatty((int)fileno(stdin)))
+    if (inspect && (isatty((int)fileno(stdin)) || is_cygpty((int)fileno(stdin))))
         sts = PyRun_AnyFile(stdin, "<stdin>") != 0;
 
 #ifdef MS_WINDOWS
diff --git a/Python/getcompiler.c b/Python/getcompiler.c
index 0f441de..ef97ad4 100644
--- a/Python/getcompiler.c
+++ b/Python/getcompiler.c
@@ -6,7 +6,22 @@
 #ifndef COMPILER
 
 #ifdef __GNUC__
-#define COMPILER "\n[GCC " __VERSION__ "]"
+/* To not break compatibility with things that determine
+   CPU arch by calling get_build_version in msvccompiler.py
+   (such as NumPy) add "32 bit" or "64 bit (AMD64)" on Windows
+   and also use a space as a separator rather than a newline. */
+#if defined(_WIN32)
+#define COMP_SEP " "
+#if defined(__x86_64__)
+#define ARCH_SUFFIX " 64 bit (AMD64)"
+#else
+#define ARCH_SUFFIX " 32 bit"
+#endif
+#else
+#define COMP_SEP "\n"
+#define ARCH_SUFFIX ""
+#endif
+#define COMPILER COMP_SEP "[GCC " __VERSION__ ARCH_SUFFIX "]"
 #endif
 
 #endif /* !COMPILER */
diff --git a/Python/getplatform.c b/Python/getplatform.c
index 6899140..d3e1538 100644
--- a/Python/getplatform.c
+++ b/Python/getplatform.c
@@ -1,6 +1,12 @@
 
 #include "Python.h"
 
+#ifdef __MINGW32__
+#  undef PLATFORM
+/* see PC/pyconfig.h */
+#  define PLATFORM "win32"
+#endif
+
 #ifndef PLATFORM
 #define PLATFORM "unknown"
 #endif
diff --git a/Python/iscygpty.c b/Python/iscygpty.c
new file mode 100644
index 0000000..722f88f
--- /dev/null
+++ b/Python/iscygpty.c
@@ -0,0 +1,185 @@
+/*
+ * iscygpty.c -- part of ptycheck
+ * https://github.com/k-takata/ptycheck
+ *
+ * Copyright (c) 2015-2017 K.Takata
+ *
+ * You can redistribute it and/or modify it under the terms of either
+ * the MIT license (as described below) or the Vim license.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef _WIN32
+
+#include <ctype.h>
+#include <io.h>
+#include <wchar.h>
+#include <windows.h>
+
+#ifdef USE_FILEEXTD
+/* VC 7.1 or earlier doesn't support SAL. */
+# if !defined(_MSC_VER) || (_MSC_VER < 1400)
+#  define __out
+#  define __in
+#  define __in_opt
+# endif
+/* Win32 FileID API Library:
+ * http://www.microsoft.com/en-us/download/details.aspx?id=22599
+ * Needed for WinXP. */
+# include <fileextd.h>
+#else /* USE_FILEEXTD */
+/* VC 8 or earlier. */
+# if defined(_MSC_VER) && (_MSC_VER < 1500)
+#  ifdef ENABLE_STUB_IMPL
+#   define STUB_IMPL
+#  else
+#   error "Win32 FileID API Library is required for VC2005 or earlier."
+#  endif
+# endif
+#endif /* USE_FILEEXTD */
+
+
+#include "iscygpty.h"
+
+//#define USE_DYNFILEID
+#ifdef USE_DYNFILEID
+typedef BOOL (WINAPI *pfnGetFileInformationByHandleEx)(
+		HANDLE                    hFile,
+		FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
+		LPVOID                    lpFileInformation,
+		DWORD                     dwBufferSize
+);
+static pfnGetFileInformationByHandleEx pGetFileInformationByHandleEx = NULL;
+
+# ifndef USE_FILEEXTD
+static BOOL WINAPI stub_GetFileInformationByHandleEx(
+		HANDLE                    hFile,
+		FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
+		LPVOID                    lpFileInformation,
+		DWORD                     dwBufferSize
+		)
+{
+	return FALSE;
+}
+# endif
+
+static void setup_fileid_api(void)
+{
+	if (pGetFileInformationByHandleEx != NULL) {
+		return;
+	}
+	pGetFileInformationByHandleEx = (pfnGetFileInformationByHandleEx)
+		GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")),
+				"GetFileInformationByHandleEx");
+	if (pGetFileInformationByHandleEx == NULL) {
+# ifdef USE_FILEEXTD
+		pGetFileInformationByHandleEx = GetFileInformationByHandleEx;
+# else
+		pGetFileInformationByHandleEx = stub_GetFileInformationByHandleEx;
+# endif
+	}
+}
+#else
+# define pGetFileInformationByHandleEx	GetFileInformationByHandleEx
+# define setup_fileid_api()
+#endif
+
+
+#define is_wprefix(s, prefix) \
+	(wcsncmp((s), (prefix), sizeof(prefix) / sizeof(WCHAR) - 1) == 0)
+
+/* Check if the fd is a cygwin/msys's pty. */
+int is_cygpty(int fd)
+{
+#ifdef STUB_IMPL
+	return 0;
+#else
+	HANDLE h;
+	int size = sizeof(FILE_NAME_INFO) + sizeof(WCHAR) * (MAX_PATH - 1);
+	FILE_NAME_INFO *nameinfo;
+	WCHAR *p = NULL;
+
+	setup_fileid_api();
+
+	h = (HANDLE) _get_osfhandle(fd);
+	if (h == INVALID_HANDLE_VALUE) {
+		return 0;
+	}
+	/* Cygwin/msys's pty is a pipe. */
+	if (GetFileType(h) != FILE_TYPE_PIPE) {
+		return 0;
+	}
+	nameinfo = malloc(size + sizeof(WCHAR));
+	if (nameinfo == NULL) {
+		return 0;
+	}
+	/* Check the name of the pipe:
+	 * '\{cygwin,msys}-XXXXXXXXXXXXXXXX-ptyN-{from,to}-master' */
+	if (pGetFileInformationByHandleEx(h, FileNameInfo, nameinfo, size)) {
+		nameinfo->FileName[nameinfo->FileNameLength / sizeof(WCHAR)] = L'\0';
+		p = nameinfo->FileName;
+		if (is_wprefix(p, L"\\cygwin-")) {		/* Cygwin */
+			p += 8;
+		} else if (is_wprefix(p, L"\\msys-")) {	/* MSYS and MSYS2 */
+			p += 6;
+		} else {
+			p = NULL;
+		}
+		if (p != NULL) {
+			while (*p && isxdigit(*p))	/* Skip 16-digit hexadecimal. */
+				++p;
+			if (is_wprefix(p, L"-pty")) {
+				p += 4;
+			} else {
+				p = NULL;
+			}
+		}
+		if (p != NULL) {
+			while (*p && isdigit(*p))	/* Skip pty number. */
+				++p;
+			if (is_wprefix(p, L"-from-master")) {
+				//p += 12;
+			} else if (is_wprefix(p, L"-to-master")) {
+				//p += 10;
+			} else {
+				p = NULL;
+			}
+		}
+	}
+	free(nameinfo);
+	return (p != NULL);
+#endif /* STUB_IMPL */
+}
+
+/* Check if at least one cygwin/msys pty is used. */
+int is_cygpty_used(void)
+{
+	int fd, ret = 0;
+
+	for (fd = 0; fd < 3; fd++) {
+		ret |= is_cygpty(fd);
+	}
+	return ret;
+}
+
+#endif /* _WIN32 */
+
+/* vim: set ts=4 sw=4: */
diff --git a/Python/pylifecycle.c b/Python/pylifecycle.c
index 640271f..c95a84f 100644
--- a/Python/pylifecycle.c
+++ b/Python/pylifecycle.c
@@ -14,6 +14,7 @@
 #include "ast.h"
 #include "marshal.h"
 #include "osdefs.h"
+#include "iscygpty.h"
 #include <locale.h>
 
 #ifdef HAVE_SIGNAL_H
@@ -888,17 +889,123 @@ Py_EndInterpreter(PyThreadState *tstate)
     PyInterpreterState_Delete(interp);
 }
 
-#ifdef MS_WINDOWS
-static wchar_t *progname = L"python";
+#if defined(_MSC_VER)
+static wchar_t progname[PATH_MAX+1] = L"python";
 #else
-static wchar_t *progname = L"python3";
+static wchar_t progname[PATH_MAX+1] = L"python3";
+#endif
+
+char
+Py_GetSepA(char *name)
+{
+    char* msystem = (char*)2; /* So that non Windows use / as sep */
+    static char sep = '\0';
+#ifdef _WIN32
+    /* https://msdn.microsoft.com/en-gb/library/windows/desktop/aa365247%28v=vs.85%29.aspx
+     * The "\\?\" prefix .. indicate that the path should be passed to the system with minimal
+     * modification, which means that you cannot use forward slashes to represent path separators
+     */
+    if (name != NULL && memcmp(name, "\\\\?\\", sizeof("\\\\?\\") - sizeof(char)) == 0)
+    {
+        return '\\';
+    }
+#endif
+    if (sep != '\0')
+        return sep;
+#if defined(__MINGW32__)
+    msystem = Py_GETENV("MSYSTEM");
 #endif
+    if (msystem != NULL)
+        sep = '/';
+    else
+        sep = '\\';
+    return sep;
+}
+
+static wchar_t
+Py_GetAltSepA(char *name)
+{
+    char sep = Py_GetSepA(name);
+    if (sep == '/')
+        return '\\';
+    return '/';
+}
+
+void
+Py_NormalizeSepsA(char *name)
+{
+    char sep = Py_GetSepA(name);
+    char altsep = Py_GetAltSepA(name);
+    char* seps;
+    if (strlen(name) > 1 && name[1] == ':') {
+        name[0] = toupper(name[0]);
+    }
+    seps = strchr(name, altsep);
+    while(seps) {
+        *seps = sep;
+        seps = strchr(seps, altsep);
+    }
+}
+
+wchar_t
+Py_GetSepW(wchar_t *name)
+{
+    char* msystem = (char*)2; /* So that non Windows use / as sep */
+    static wchar_t sep = L'\0';
+#ifdef _WIN32
+    /* https://msdn.microsoft.com/en-gb/library/windows/desktop/aa365247%28v=vs.85%29.aspx
+     * The "\\?\" prefix .. indicate that the path should be passed to the system with minimal
+     * modification, which means that you cannot use forward slashes to represent path separators
+     */
+    if (name != NULL && memcmp(name, L"\\\\?\\", sizeof(L"\\\\?\\") - sizeof(wchar_t)) == 0)
+    {
+        return L'\\';
+    }
+#endif
+    if (sep != L'\0')
+        return sep;
+#if defined(__MINGW32__)
+    msystem = Py_GETENV("MSYSTEM");
+#endif
+    if (msystem != NULL)
+        sep = L'/';
+    else
+        sep = L'\\';
+    return sep;
+}
+
+static wchar_t
+Py_GetAltSepW(wchar_t *name)
+{
+    char sep = Py_GetSepW(name);
+    if (sep == L'/')
+        return L'\\';
+    return L'/';
+}
+
+void
+Py_NormalizeSepsW(wchar_t *name)
+{
+    wchar_t sep = Py_GetSepW(name);
+    wchar_t altsep = Py_GetAltSepW(name);
+    wchar_t* seps;
+    if (wcslen(name) > 1 && name[1] == L':') {
+        name[0] = towupper(name[0]);
+    }
+    seps = wcschr(name, altsep);
+    while(seps) {
+        *seps = sep;
+        seps = wcschr(seps, altsep);
+    }
+}
 
 void
 Py_SetProgramName(wchar_t *pn)
 {
     if (pn && *pn)
-        progname = pn;
+        wcsncpy(progname, pn, PATH_MAX);
+    pn = &progname[0];
+    Py_NormalizeSepsW(pn);
 }
 
 wchar_t *
@@ -1599,7 +1706,7 @@ _Py_RestoreSignals(void)
 int
 Py_FdIsInteractive(FILE *fp, const char *filename)
 {
-    if (isatty((int)fileno(fp)))
+    if (isatty((int)fileno(fp)) || is_cygpty((int)fileno(fp)))
         return 1;
     if (!Py_InteractiveFlag)
         return 0;
diff --git a/Python/pytime.c b/Python/pytime.c
index b416eff..9dfaddd 100644
--- a/Python/pytime.c
+++ b/Python/pytime.c
@@ -550,7 +550,7 @@ pygettimeofday(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
     /* 11,644,473,600,000,000,000: number of nanoseconds between
        the 1st january 1601 and the 1st january 1970 (369 years + 89 leap
        days). */
-    *tp = large.QuadPart * 100 - 11644473600000000000;
+    *tp = large.QuadPart * 100 - 11644473600000000000ULL;
     if (info) {
         DWORD timeAdjustment, timeIncrement;
         BOOL isTimeAdjustmentDisabled, ok;
@@ -644,6 +644,35 @@ _PyTime_GetSystemClockWithInfo(_PyTime_t *t, _Py_clock_info_t *info)
     return pygettimeofday(t, info, 1);
 }
 
+#if defined(MS_WINDOWS) && _WIN32_WINNT < 0x0600
+/* GetTickCount64() is not available on XP. */
+ULONGLONG GetTickCount64 ()
+{
+    static ULONGLONG (CALLBACK *Py_GetTickCount64)() = (ULONGLONG (*)(void))-1;
+    static DWORD last_ticks = 0;
+    static DWORD n_overflow = 0;
+    DWORD ticks = 0;
+    HINSTANCE hKernel32;
+
+    if (Py_GetTickCount64 == (void*)-1)
+    {
+        hKernel32 = GetModuleHandleW(L"KERNEL32");
+        Py_GetTickCount64 = *(ULONGLONG (*)(void))(GetProcAddress(hKernel32,
+                                        "GetTickCount64"));
+    }
+    if (Py_GetTickCount64 != (void*) NULL)
+    {
+        return Py_GetTickCount64();
+    }
+
+    ticks = GetTickCount();
+    if (ticks < last_ticks)
+        n_overflow++;
+    last_ticks = ticks;
+    return ((ULONGLONG)n_overflow << 32LL) + (ULONGLONG)GetTickCount();
+}
+#endif
+
 static int
 pymonotonic(_PyTime_t *tp, _Py_clock_info_t *info, int raise)
 {
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index b09268b..9d0a720 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -27,7 +27,7 @@ Data members:
 #include <windows.h>
 #endif /* MS_WINDOWS */
 
-#ifdef MS_COREDLL
+#if defined(MS_WINDOWS) && defined(Py_ENABLE_SHARED)
 extern void *PyWin_DLLhModule;
 /* A string loaded from the DLL at startup: */
 extern const char *PyWin_DLLVersionString;
@@ -1989,7 +1989,7 @@ _PySys_Init(void)
                         PyUnicode_FromString("little"));
 #endif
 
-#ifdef MS_COREDLL
+#if defined(MS_WINDOWS) && defined(Py_ENABLE_SHARED)
     SET_SYS_FROM_STRING("dllhandle",
                         PyLong_FromVoidPtr(PyWin_DLLhModule));
     SET_SYS_FROM_STRING("winver",
@@ -2240,7 +2240,7 @@ sys_update_path(int argc, wchar_t **argv)
             argv0 = fullpath;
         }
 #endif
-        p = wcsrchr(argv0, SEP);
+        p = wcsrchr(argv0, Py_GetSepW(argv0));
     }
     if (p != NULL) {
         n = p + 1 - argv0;
diff --git a/Python/thread.c b/Python/thread.c
index 63eeb1e..55936ca 100644
--- a/Python/thread.c
+++ b/Python/thread.c
@@ -7,6 +7,12 @@
 
 #include "Python.h"
 
+#ifdef __MINGW32__
+# if !defined(HAVE_PTHREAD_H) || defined(NT_THREADS)
+#  undef _POSIX_THREADS
+# endif
+#endif
+
 #ifndef _POSIX_THREADS
 /* This means pthreads are not implemented in libc headers, hence the macro
    not present in unistd.h. But they still can be implemented as an external
diff --git a/Python/traceback.c b/Python/traceback.c
index 9f8c568..f63a1db 100644
--- a/Python/traceback.c
+++ b/Python/traceback.c
@@ -205,7 +205,7 @@ _Py_FindSourceFile(PyObject *filename, char* namebuf, size_t namelen, PyObject *
     filepath = PyBytes_AS_STRING(filebytes);
 
     /* Search tail of filename in sys.path before giving up */
-    tail = strrchr(filepath, SEP);
+    tail = strrchr(filepath, Py_GetSepW(filepath));
     if (tail == NULL)
         tail = filepath;
     else
diff --git a/configure.ac b/configure.ac
index e400fa1..d059f8f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -362,10 +362,22 @@ AC_SUBST(FRAMEWORKINSTALLAPPSPREFIX)
 # Set name for machine-dependent library files
 AC_ARG_VAR([MACHDEP], [name for machine-dependent library files])
 AC_MSG_CHECKING(MACHDEP)
+case $host in
+  *-*-mingw*)
+    # On those hosts MACHDEP is 'win', as platform specific files
+    # go in plat-$(MACHDEP), but runtime platform is 'win32'
+    test -z "$MACHDEP" && MACHDEP=win
+
+    dnl Configuration will be based only on "host triplet" as build
+    dnl must not depend from posix compatible environement.
+    ac_sys_system=ignore
+    ;;
+esac
 if test -z "$MACHDEP"
 then
     # avoid using uname for cross builds
     if test "$cross_compiling" = yes; then
+       ac_sys_release=
        # ac_sys_system and ac_sys_release are used for setting
        # a lot of different things including 'define_xopen_source'
        # in the case statement below.
@@ -379,12 +391,32 @@ then
 	*-*-cygwin*)
 		ac_sys_system=Cygwin
 		;;
+	*-*-darwin*)
+		ac_sys_system=Darwin
+		ac_sys_release=$(echo $host | sed -n 's/.*-[^0-9]\+\([0-9]\+\)/\1/p')
+		if test -z "$ac_sys_release"; then
+			# A reasonable default.
+			ac_sys_release=11
+		fi
+		# Use the last released version number for old versions.
+	        if test "$ac_sys_release" = "9" ; then
+			ac_sys_release=9.8
+	        elif test "$ac_sys_release" = "10" ; then
+			ac_sys_release=10.8
+	        elif test "$ac_sys_release" = "11" ; then
+			ac_sys_release=11.4.0
+	        elif test "$ac_sys_release" = "12" ; then
+			ac_sys_release=12.0.0
+		else
+		# ..and .0.0 for unknown versions.
+			ac_sys_release=${ac_sys_release}.0.0
+		fi
+		;;
 	*)
 		# for now, limit cross builds to known configurations
 		MACHDEP="unknown"
 		AC_MSG_ERROR([cross build not supported for $host])
 	esac
-	ac_sys_release=
     else
 	ac_sys_system=`uname -s`
 	if test "$ac_sys_system" = "AIX" \
@@ -424,12 +456,26 @@ if test "$cross_compiling" = yes; then
 	*-*-cygwin*)
 		_host_cpu=
 		;;
+	*-*-mingw*)
+		_host_cpu=
+		;;
+	*-*-darwin*)
+		_host_cpu=
+		;;
 	*)
 		# for now, limit cross builds to known configurations
 		MACHDEP="unknown"
 		AC_MSG_ERROR([cross build not supported for $host])
 	esac
 	_PYTHON_HOST_PLATFORM="$MACHDEP${_host_cpu:+-$_host_cpu}"
+
+	case "$host_os" in
+	mingw*)
+	# As sys.platform() return 'win32' to build python and extantions
+	# we will use 'mingw' (in setup.py and etc.)
+	_PYTHON_HOST_PLATFORM=mingw
+	;;
+	esac
 fi
 
 # Some systems cannot stand _XOPEN_SOURCE being defined at all; they
@@ -562,6 +608,83 @@ then
 fi
 AC_MSG_RESULT($MACHDEP)
 
+# Windows uses ; to separate paths, everything else uses :
+AC_MSG_CHECKING(DELIM)
+DELIM=:
+if test "$MACHDEP" = "win"
+then
+	DELIM=\;
+fi
+AC_MSG_RESULT([$DELIM])
+AC_SUBST(DELIM)
+
+# On 'semi-native' build systems (MSYS*/Cygwin targeting MinGW-w64)
+# _sysconfigdata.py will contain paths that are correct only in the
+# build environment. This means external modules will fail to build
+# without setting up the same env and also that the build of Python
+# itself will fail as the paths are not correct for the host tools.
+#
+# Also, getpath.c uses GetModuleFileNameW (replacing \ with /) and
+# compares that with the define VPATH (passed in via command-line)
+# to determine whether it's the build- or the installed-Python.
+#
+# To work around these issues a set of _b2h variables are created:
+# VPATH_b2h, prefix_b2h, srcdir_b2h, abs_srcdir_b2h
+# and abs_builddir_b2h
+# .. where b2h stands for build to host. sysconfig.py replaces path
+# prefixes matching the non-b2h versions with the b2h equivalents.
+#
+# (note this assumes the host compilers are native and *not* cross
+#  - in the 'semi-native' scenario only that is.)
+
+AC_DEFUN([ABS_PATH_HOST],
+[$1=$(cd $$2 && pwd)
+  case $build_os in
+    mingw*)
+      case $host_os in
+        mingw*) $1=$(cd $$2 && pwd -W) ;;
+        *) ;;
+      esac
+      ;;
+    cygwin*)
+      case $host_os in
+        mingw*) $1=$(cygpath -w -m $$2) ;;
+        *) ;;
+      esac
+      ;;
+  esac
+AC_SUBST([$1])
+])
+
+AC_MSG_CHECKING(absolute host location of VPATH)
+ABS_PATH_HOST([VPATH_b2h],[srcdir])
+AC_MSG_RESULT([$VPATH_b2h])
+
+AC_MSG_CHECKING(absolute host location of prefix)
+ABS_PATH_HOST([prefix_b2h],[prefix])
+AC_MSG_RESULT([$prefix_b2h])
+
+AC_MSG_CHECKING(absolute host location of srcdir)
+ABS_PATH_HOST([srcdir_b2h],[srcdir])
+AC_MSG_RESULT([$srcdir_b2h])
+
+AC_MSG_CHECKING(absolute host location of abs_srcdir)
+ABS_PATH_HOST([abs_srcdir_b2h],[srcdir])
+AC_MSG_RESULT([$abs_srcdir_b2h])
+
+my_builddir=.
+AC_MSG_CHECKING(Absolute host location of abs_builddir)
+ABS_PATH_HOST([abs_builddir_b2h],[my_builddir])
+AC_MSG_RESULT([$abs_builddir_b2h])
+
+AC_MSG_CHECKING([for init system calls])
+AC_SUBST(INITSYS)
+case $host in
+  *-*-mingw*)	INITSYS=nt;;
+  *)		INITSYS=posix;;
+esac
+AC_MSG_RESULT([$INITSYS])
+
 # Record the configure-time value of MACOSX_DEPLOYMENT_TARGET,
 # it may influence the way we can build extensions, so distutils
 # needs to check it
@@ -888,6 +1011,28 @@ if test x$MULTIARCH != x; then
 fi
 AC_SUBST(MULTIARCH_CPPFLAGS)
 
+# initialize default configuration
+py_config=
+case $host in
+  *-*-mingw*) py_config=mingw ;;
+esac
+if test -n "$py_config" ; then
+  AC_MSG_NOTICE([loading configure defaults from .../Misc/config_$py_config"])
+  . "$srcdir/Misc/config_$py_config"
+fi
+
+# initialize defaults for cross-builds
+if test "$cross_compiling" = yes; then
+  py_config=$host_os
+  case $py_config in
+    mingw32*) py_config=mingw32 ;;
+  esac
+  if test -f "$srcdir/Misc/cross_$py_config" ; then
+    AC_MSG_NOTICE([loading cross defaults from .../Misc/cross_$py_config"])
+    . "$srcdir/Misc/cross_$py_config"
+  fi
+fi
+
 AC_MSG_CHECKING([for -Wl,--no-as-needed])
 save_LDFLAGS="$LDFLAGS"
 LDFLAGS="$LDFLAGS -Wl,--no-as-needed"
@@ -1180,6 +1325,13 @@ if test $enable_shared = "yes"; then
 	;;
 
   esac
+  case $host in
+    *-*-mingw*)
+        LDLIBRARY='libpython$(LDVERSION).dll.a'
+        DLLLIBRARY='libpython$(LDVERSION).dll'
+        BLDLIBRARY='-L. -lpython$(LDVERSION)'
+        ;;
+  esac
 else # shared is disabled
   PY_ENABLE_SHARED=0
   case $ac_sys_system in
@@ -1188,6 +1340,10 @@ else # shared is disabled
           LDLIBRARY='libpython$(LDVERSION).dll.a'
           ;;
   esac
+  case $host in
+    *-*-mingw*)
+          LDLIBRARY='libpython$(LDVERSION).a';;
+  esac
 fi
 
 if test "$cross_compiling" = yes; then
@@ -1530,6 +1686,26 @@ fi
 AC_SUBST(BASECFLAGS)
 AC_SUBST(CFLAGS_NODIST)
 
+if test "x$cross_compiling" = xyes; then
+    function cross_arch
+    {
+        case $host in
+	  x86_64*darwin*)
+	    echo i386
+          ;;
+	  x86_64*)
+            echo x86_64
+	  ;;
+	  *)
+            echo i386
+	  ;;
+	esac
+    }
+    ARCH_PROG=cross_arch
+else
+    ARCH_PROG=/usr/bin/arch
+fi
+
 # The -arch flags for universal builds on OSX
 UNIVERSAL_ARCH_FLAGS=
 AC_SUBST(UNIVERSAL_ARCH_FLAGS)
@@ -1834,7 +2010,7 @@ yes)
                     ;;
                 esac
             else
-                if test `/usr/bin/arch` = "i386"
+                if test "$($ARCH_PROG)" = "i386"
                 then
                     # 10.4 was the first release to support Intel archs
                     cur_target="10.4"
@@ -1887,6 +2063,37 @@ then
 	BASECFLAGS="$BASECFLAGS $ac_arch_flags"
 fi
 
+dnl NOTE:
+dnl - GCC 4.4+ for mingw* require and use posix threads(pthreads-w32)
+dnl - Host may contain installed pthreads-w32.
+dnl - On windows platform only NT-thread model is supported.
+dnl To avoid miss detection scipt first will check for NT-thread model
+dnl and if is not found will try to detect build options for pthread
+dnl model. Autodetection could be overiden if variable ac_cv_ntthread
+dnl is set in "Site Configuration" (see autoconf manual).
+dnl If NT-thread model is enabled script skips some checks that
+dnl impact build process. When a new functionality is added, developers
+dnl are responsible to update configure script to avoid thread models
+dnl to be mixed.
+
+AC_MSG_CHECKING([for NT threads])
+AC_CACHE_VAL([ac_cv_ntthread],[
+  AC_LINK_IFELSE([
+    AC_LANG_PROGRAM([[]],[[_beginthread(0, 0, 0);]])
+  ],
+  [ac_cv_ntthread=yes],
+  [ac_cv_ntthread=no])
+])
+AC_MSG_RESULT([$ac_cv_ntthread])
+
+if test $ac_cv_ntthread = yes ; then
+  dnl temporary default flag to avoid additional pthread checks
+  dnl and initilize other ac..thread flags to no
+  ac_cv_pthread_is_default=yes
+  ac_cv_kthread=no
+  ac_cv_pthread=no
+  dnl ac_cv_kpthread is set to no if default is yes (see below)
+else
 # On some compilers, pthreads are available without further options
 # (e.g. MacOS X). On some of these systems, the compiler will not
 # complain if unaccepted options are passed (e.g. gcc on Mac OS X).
@@ -1914,6 +2121,7 @@ int main(){
 ],[ac_cv_pthread_is_default=no],[ac_cv_pthread_is_default=no])
 ])
 AC_MSG_RESULT($ac_cv_pthread_is_default)
+fi
 
 
 if test $ac_cv_pthread_is_default = yes
@@ -2005,6 +2213,9 @@ CC="$ac_save_cc"])
 AC_MSG_RESULT($ac_cv_pthread)
 fi
 
+dnl unset temporary pthread default if NT-thread model is enabled
+test $ac_cv_ntthread = yes && ac_cv_pthread_is_default=no
+
 # If we have set a CC compiler flag for thread support then
 # check if it works for CXX, too.
 ac_cv_cxx_thread=no
@@ -2025,6 +2236,10 @@ elif test "$ac_cv_pthread" = "yes"
 then
   CXX="$CXX -pthread"
   ac_cv_cxx_thread=yes
+elif test $ac_cv_ntthread = yes
+then
+  dnl set to always to skip extra pthread check below
+  ac_cv_cxx_thread=always
 fi
 
 if test $ac_cv_cxx_thread = yes
@@ -2054,10 +2269,15 @@ dnl ]], [[;]])],[cpp_type=ansi],[AC_DEFINE(HAVE_OLD_CPP) cpp_type=traditional])
 dnl AC_MSG_RESULT($cpp_type)
 
 # checks for header files
+if test $ac_cv_ntthread = yes ; then
+  dnl skip checks for some pthread headers if NT-thread model is enabled
+  ac_cv_header_sched_h=skip
+  ac_cv_header_pthread_h=skip
+fi
 AC_HEADER_STDC
 AC_CHECK_HEADERS(asm/types.h conio.h direct.h dlfcn.h errno.h \
 fcntl.h grp.h \
-ieeefp.h io.h langinfo.h libintl.h process.h pthread.h \
+ieeefp.h io.h langinfo.h libintl.h process.h \
 sched.h shadow.h signal.h stropts.h termios.h \
 unistd.h utime.h \
 poll.h sys/devpoll.h sys/epoll.h sys/poll.h \
@@ -2246,8 +2466,20 @@ AC_CHECK_SIZEOF(off_t, [], [
 ])
 
 AC_MSG_CHECKING(whether to enable large file support)
+have_largefile_support=no
 if test "$ac_cv_sizeof_off_t" -gt "$ac_cv_sizeof_long" -a \
 	"$ac_cv_sizeof_long_long" -ge "$ac_cv_sizeof_off_t"; then
+  have_largefile_support=yes
+else
+  case $host in
+  *-*-mingw*)
+    dnl Activate on windows platforms (32&64-bit) where off_t(4) < fpos_t(8)
+    have_largefile_support=yes
+    ;;
+  esac
+fi
+
+if test $have_largefile_support = yes ; then
   AC_DEFINE(HAVE_LARGEFILE_SUPPORT, 1,
   [Defined to enable large file support when an off_t is bigger than a long
    and long long is available and at least as big as an off_t. You may need
@@ -2279,9 +2511,14 @@ fi
 
 AC_MSG_CHECKING(for pthread_t)
 have_pthread_t=no
+if test $ac_cv_ntthread = yes ; then
+  dnl skip check for pthread_t if NT-thread model is enabled
+  have_pthread_t=skip
+else
 AC_COMPILE_IFELSE([
   AC_LANG_PROGRAM([[#include <pthread.h>]], [[pthread_t x; x = *(pthread_t*)0;]])
 ],[have_pthread_t=yes],[])
+fi
 AC_MSG_RESULT($have_pthread_t)
 if test "$have_pthread_t" = yes ; then
   AC_CHECK_SIZEOF(pthread_t, [], [
@@ -2310,7 +2547,7 @@ case $ac_sys_system/$ac_sys_release in
     if test "${enable_universalsdk}"; then
 	    :
     else
-        LIBTOOL_CRUFT="${LIBTOOL_CRUFT} -arch_only `/usr/bin/arch`"
+        LIBTOOL_CRUFT="${LIBTOOL_CRUFT} -arch_only $($ARCH_PROG)"
     fi
     LIBTOOL_CRUFT=$LIBTOOL_CRUFT' -install_name $(PYTHONFRAMEWORKINSTALLDIR)/Versions/$(VERSION)/$(PYTHONFRAMEWORK)'
     LIBTOOL_CRUFT=$LIBTOOL_CRUFT' -compatibility_version $(VERSION) -current_version $(VERSION)';;
@@ -2335,7 +2572,7 @@ case $ac_sys_system/$ac_sys_release in
     ]])],[ac_osx_32bit=yes],[ac_osx_32bit=no],[ac_osx_32bit=yes])
 
     if test "${ac_osx_32bit}" = "yes"; then
-    	case `/usr/bin/arch` in
+	case $($ARCH_PROG) in
     	i386)
     		MACOSX_DEFAULT_ARCH="i386"
     		;;
@@ -2347,7 +2584,7 @@ case $ac_sys_system/$ac_sys_release in
     		;;
     	esac
     else
-    	case `/usr/bin/arch` in
+	case $($ARCH_PROG) in
     	i386)
     		MACOSX_DEFAULT_ARCH="x86_64"
     		;;
@@ -2419,6 +2656,9 @@ if test -z "$SHLIB_SUFFIX"; then
 	CYGWIN*)   SHLIB_SUFFIX=.dll;;
 	*)	   SHLIB_SUFFIX=.so;;
 	esac
+	case $host_os in
+	mingw*)    SHLIB_SUFFIX=.dll;;
+	esac
 fi
 AC_MSG_RESULT($SHLIB_SUFFIX)
 
@@ -2559,6 +2799,12 @@ then
 		LDCXXSHARED="g++ -shared -Wl,--enable-auto-image-base";;
 	*)	LDSHARED="ld";;
 	esac
+	case $host in
+	*-*-mingw*)
+		LDSHARED='$(CC) -shared -Wl,--enable-auto-image-base'
+		LDCXXSHARED='$(CXX) -shared -Wl,--enable-auto-image-base'
+		;;
+	esac
 fi
 AC_MSG_RESULT($LDSHARED)
 LDCXXSHARED=${LDCXXSHARED-$LDSHARED}
@@ -2697,17 +2943,33 @@ AC_CHECK_LIB(dl, dlopen)	# Dynamic linking for SunOS/Solaris and SYSV
 AC_CHECK_LIB(dld, shl_load)	# Dynamic linking for HP-UX
 
 # only check for sem_init if thread support is requested
+if test $ac_cv_ntthread = yes ; then
+  dnl do not search for sem_init if NT-thread model is enabled
+  :
+else
 if test "$with_threads" = "yes" -o -z "$with_threads"; then
-    AC_SEARCH_LIBS(sem_init, pthread rt posix4) # 'Real Time' functions on Solaris
-						# posix4 on Solaris 2.6
-						# pthread (first!) on Linux
+    if test "$ac_cv_ntthread" = "no" -o -z "$ac_cv_ntthread"; then
+        AC_SEARCH_LIBS(sem_init, pthread rt posix4) # 'Real Time' functions on Solaris
+							# posix4 on Solaris 2.6
+							# pthread (first!) on Linux
+    fi
+fi
 fi
 
 # check if we need libintl for locale functions
+case $host in
+  *-*-mingw*)
+  dnl Native windows build don't use libintl (see _localemodule.c).
+  dnl Also we don't like setup.py to add "intl" library to the list
+  dnl when build _locale module.
+  ;;
+  *)
 AC_CHECK_LIB(intl, textdomain,
 	[AC_DEFINE(WITH_LIBINTL, 1,
 	[Define to 1 if libintl is needed for locale functions.])
         LIBS="-lintl $LIBS"])
+  ;;
+esac
 
 # checks for system dependent C++ extensions support
 case "$ac_sys_system" in
@@ -2909,6 +3171,21 @@ else
 fi])
 AC_MSG_RESULT($with_dbmliborder)
 
+
+# Determine if windows modules should be used.
+AC_SUBST(USE_WIN32_MODULE)
+USE_WIN32_MODULE='#'
+case $host in
+  *-*-mingw*) USE_WIN32_MODULE=;;
+esac
+
+# Determine if pwdmodule should be used.
+AC_SUBST(USE_PWD_MODULE)
+USE_PWD_MODULE=
+case $host in
+  *-*-mingw*) USE_PWD_MODULE='#';;
+esac
+
 # This is used to generate Setup.config
 AC_SUBST(USE_THREAD_MODULE)
 USE_THREAD_MODULE=""
@@ -2976,6 +3253,13 @@ then
     AC_DEFINE(WITH_THREAD)
     posix_threads=yes
     THREADOBJ="Python/thread.o"
+elif test $ac_cv_ntthread = yes
+then
+    AC_DEFINE(WITH_THREAD)
+    posix_threads=no
+    THREADOBJ="Python/thread.o"
+    AC_DEFINE(NT_THREADS, 1,
+	[Define to 1 if you want to use native NT threads])
 else
     if test ! -z "$with_threads" -a -d "$with_threads"
     then LDFLAGS="$LDFLAGS -L$with_threads"
@@ -3398,6 +3682,12 @@ then
 	fi
 	;;
 	esac
+	case $host in
+	*-*-mingw*)
+	DYNLOADFILE="dynload_win.o"
+	extra_machdep_objs="$extra_machdep_objs PC/dl_nt.o"
+	;;
+	esac
 fi
 AC_MSG_RESULT($DYNLOADFILE)
 if test "$DYNLOADFILE" != "dynload_stub.o"
@@ -3423,6 +3713,15 @@ else
 fi
 
 # checks for library functions
+if test $ac_cv_ntthread = yes ; then
+  dnl GCC(mingw) 4.4+ require and use posix threads(pthreads-w32)
+  dnl and host may contain installed pthreads-w32.
+  dnl Skip checks for some functions declared in pthreads-w32 if
+  dnl NT-thread model is enabled.
+  ac_cv_func_pthread_kill=skip
+  ac_cv_func_sem_open=skip
+  ac_cv_func_sched_setscheduler=skip
+fi
 AC_CHECK_FUNCS(alarm accept4 setitimer getitimer bind_textdomain_codeset chown \
  clock confstr ctermid dup3 execv faccessat fchmod fchmodat fchown fchownat \
  fexecve fdopendir fork fpathconf fstatat ftime ftruncate futimesat \
@@ -3987,21 +4286,36 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 ],[])
 AC_MSG_RESULT($was_it_defined)
 
+AC_CHECK_HEADERS([ws2tcpip.h])
 AC_MSG_CHECKING(for addrinfo)
 AC_CACHE_VAL(ac_cv_struct_addrinfo,
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]], [[struct addrinfo a]])],
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#ifdef HAVE_WS2TCPIP_H
+#  include <ws2tcpip.h>
+#else
+#  include <netdb.h>
+#endif]],
+    [[struct addrinfo a]])],
   [ac_cv_struct_addrinfo=yes],
   [ac_cv_struct_addrinfo=no]))
 AC_MSG_RESULT($ac_cv_struct_addrinfo)
 if test $ac_cv_struct_addrinfo = yes; then
-	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo (netdb.h)])
+	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo])
 fi
 
 AC_MSG_CHECKING(for sockaddr_storage)
 AC_CACHE_VAL(ac_cv_struct_sockaddr_storage,
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#		include <sys/types.h>
-#		include <sys/socket.h>]], [[struct sockaddr_storage s]])],
+#ifdef HAVE_WS2TCPIP_H
+#include <ws2tcpip.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif]],
+    [[struct sockaddr_storage s]])],
   [ac_cv_struct_sockaddr_storage=yes],
   [ac_cv_struct_sockaddr_storage=no]))
 AC_MSG_RESULT($ac_cv_struct_sockaddr_storage)
@@ -4469,6 +4783,10 @@ LIBS=$LIBS_SAVE
 # the kernel module that provides POSIX semaphores
 # isn't loaded by default, so an attempt to call
 # sem_open results in a 'Signal 12' error.
+if test $ac_cv_ntthread = yes ; then
+  dnl skip posix semaphores test if NT-thread model is enabled
+  ac_cv_posix_semaphores_enabled=no
+fi
 AC_MSG_CHECKING(whether POSIX semaphores are enabled)
 AC_CACHE_VAL(ac_cv_posix_semaphores_enabled,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
@@ -4502,6 +4820,14 @@ fi
 
 # Multiprocessing check for broken sem_getvalue
 AC_MSG_CHECKING(for broken sem_getvalue)
+if test $ac_cv_ntthread = yes ; then
+  dnl Skip test if NT-thread model is enabled.
+  dnl NOTE the test case below fail for pthreads-w32 as:
+  dnl - SEM_FAILED is not defined;
+  dnl - sem_open is a stub;
+  dnl - sem_getvalue work(!).
+  ac_cv_broken_sem_getvalue=skip
+fi
 AC_CACHE_VAL(ac_cv_broken_sem_getvalue,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <unistd.h>
@@ -4649,6 +4975,12 @@ case $ac_sys_system in
     *)
 	EXT_SUFFIX=${SHLIB_SUFFIX};;
 esac
+case $host_os in
+    mingw*)
+	dnl Synchronized with _PyImport_DynLoadFiletab (dynload_win.c)
+	dnl Do not use more then one dot on this platform !
+	EXT_SUFFIX=-$SOABI$SHLIB_SUFFIX;;
+esac
 
 AC_MSG_CHECKING(LDVERSION)
 LDVERSION='$(VERSION)$(ABIFLAGS)'
@@ -4766,9 +5098,16 @@ AC_CHECK_LIB(readline, rl_completion_display_matches_hook,
         [Define if you have readline 4.0]), ,$READLINE_LIBS)
 
 # also in 4.0, but not in editline
+case $host in
+  *-*-mingw*)
+  dnl Windows don't have resize terminal signal.
+  ;;
+  *)
 AC_CHECK_LIB(readline, rl_resize_terminal,
 	AC_DEFINE(HAVE_RL_RESIZE_TERMINAL, 1,
         [Define if you have readline 4.0]), ,$READLINE_LIBS)
+  ;;
+esac
 
 # check for readline 4.2
 AC_CHECK_LIB(readline, rl_completion_matches,
@@ -4969,6 +5308,14 @@ fi
 
 AC_CHECK_HEADERS(curses.h ncurses.h)
 
+# If using nt threads, don't look for pthread.h or thread.h
+if test "x$ac_cv_ntthread" = xno ; then
+AC_HEADER_STDC
+AC_CHECK_HEADERS(pthread.h thread.h)
+AC_HEADER_DIRENT
+AC_HEADER_MAJOR
+fi
+
 # On Solaris, term.h requires curses.h
 AC_CHECK_HEADERS(term.h,,,[
 #ifdef HAVE_CURSES_H
@@ -4994,15 +5341,51 @@ then
 fi
 
 AC_MSG_CHECKING(whether WINDOW has _flags)
-AC_CACHE_VAL(ac_cv_window_has_flags,
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <curses.h>]], [[
   WINDOW *w;
   w->_flags = 0;
 ]])],
 [ac_cv_window_has_flags=yes],
-[ac_cv_window_has_flags=no]))
+[ac_cv_window_has_flags=no])
 AC_MSG_RESULT($ac_cv_window_has_flags)
 
+py_curses_window_is_opaque=no
+if test no = $ac_cv_window_has_flags; then
+  AC_MSG_CHECKING([whether WINDOW has _flags in non-opaque structure])
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM([[
+    #define NCURSES_OPAQUE 0
+    #include <curses.h>
+  ]],[[
+    WINDOW *w;
+    w->_flags = 0;
+  ]])],
+  [py_curses_window_is_opaque=yes])
+  AC_MSG_RESULT([$py_curses_window_is_opaque])
+fi
+if test yes = $py_curses_window_is_opaque; then
+  ac_cv_window_has_flags=yes
+  AC_DEFINE([NCURSES_OPAQUE], [0], [Define to 0 if you have WINDOW _flags in non-opaque structure.])
+fi
+
+py_curses_window_is_internal=no
+if test no = $ac_cv_window_has_flags; then
+  AC_MSG_CHECKING([whether WINDOW has _flags as internal structure])
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM([[
+    #define NCURSES_INTERNALS 1
+    #include <curses.h>
+  ]],[[
+    WINDOW *w;
+    w->_flags = 0;
+  ]])],
+  [py_curses_window_is_internal=yes])
+  AC_MSG_RESULT([$py_curses_window_is_internal])
+fi
+if test yes = $py_curses_window_is_internal; then
+  ac_cv_window_has_flags=yes
+  AC_DEFINE([NCURSES_INTERNALS], [1], [Define to 1 if you have WINDOW _flags as internal structure.])
+fi
 
 if test "$ac_cv_window_has_flags" = yes
 then
@@ -5113,7 +5496,10 @@ fi
 
 AC_CHECK_TYPE(socklen_t,,
   AC_DEFINE(socklen_t,int,
-            [Define to `int' if <sys/socket.h> does not define.]),[
+            [Define to `int' if <sys/socket.h> or <ws2tcpip.h> does not define.]),[
+#ifdef HAVE_WS2TCPIP_H
+#include <ws2tcpip.h>
+#endif
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
@@ -5206,8 +5592,42 @@ do
   THREADHEADERS="$THREADHEADERS \$(srcdir)/$h"
 done
 
+case $host in
+  *-*-mingw*)
+    dnl Required for windows builds as Objects/exceptions.c require
+    dnl "errmap.h" from $srcdir/PC.
+    dnl Note we cannot use BASECPPFLAGS as autogenerated pyconfig.h
+    dnl has to be before customized located in ../PC.
+    dnl (-I. at end is workaround for setup.py logic)
+    CPPFLAGS="-I\$(srcdir)/PC $CPPFLAGS -I."
+    ;;
+esac
+
+dnl getpath module - default sys.path calculations
+AC_SUBST(MODULE_GETPATH)
+MODULE_GETPATH=Modules/getpath.o
+case $host in
+  *-*-mingw*)
+    dnl default sys.path calculations for windows platforms
+    MODULE_GETPATH=Modules/getpath.o
+    ;;
+esac
+
+dnl Python interpreter main program for frozen scripts
+AC_SUBST(PYTHON_OBJS_FROZENMAIN)
+PYTHON_OBJS_FROZENMAIN="Python/frozenmain.o"
+case $host in
+  *-*-mingw*)
+    dnl 'PC/frozen_dllmain.c' - not yet
+    PYTHON_OBJS_FROZENMAIN=
+    ;;
+esac
+
 AC_SUBST(SRCDIRS)
 SRCDIRS="Parser Grammar Objects Python Modules Mac Programs"
+case $host in
+  *-*-mingw*) SRCDIRS="$SRCDIRS PC";;
+esac
 AC_MSG_CHECKING(for build directories)
 for dir in $SRCDIRS; do
     if test ! -d $dir; then
@@ -5216,6 +5636,15 @@ for dir in $SRCDIRS; do
 done
 AC_MSG_RESULT(done)
 
+# For mingw build need additional library for linking
+case $host in
+  *-*-mingw*)
+    LIBS="$LIBS -lversion"
+  ;;
+  *)
+  ;;
+esac
+
 # Availability of -O2:
 AC_MSG_CHECKING(for -O2)
 saved_cflags="$CFLAGS"
diff --git a/pyconfig.h.in b/pyconfig.h.in
index cdcb570..18fa0bc 100644
--- a/pyconfig.h.in
+++ b/pyconfig.h.in
@@ -46,7 +46,7 @@
 /* Define to 1 if you have the `acosh' function. */
 #undef HAVE_ACOSH
 
-/* struct addrinfo (netdb.h) */
+/* struct addrinfo */
 #undef HAVE_ADDRINFO
 
 /* Define to 1 if you have the `alarm' function. */
@@ -1200,6 +1200,9 @@
 /* Define to 1 if you have the `writev' function. */
 #undef HAVE_WRITEV
 
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+#undef HAVE_WS2TCPIP_H
+
 /* Define if the zlib library has inflateCopy */
 #undef HAVE_ZLIB_COPY
 
@@ -1220,6 +1223,15 @@
 /* Define if mvwdelch in curses.h is an expression. */
 #undef MVWDELCH_IS_EXPRESSION
 
+/* Define to 1 if you want to use native NT threads */
+#undef NT_THREADS
+
+/* Define to 1 if you have WINDOW _flags as internal structure. */
+#undef NCURSES_INTERNALS
+
+/* Define to 0 if you have WINDOW _flags in non-opaque structure. */
+#undef NCURSES_OPAQUE
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
@@ -1505,7 +1517,7 @@
 /* Define to `unsigned int' if <sys/types.h> does not define. */
 #undef size_t
 
-/* Define to `int' if <sys/socket.h> does not define. */
+/* Define to `int' if <sys/socket.h> or <ws2tcpip.h> does not define. */
 #undef socklen_t
 
 /* Define to `int' if <sys/types.h> doesn't define. */
diff --git a/setup.py b/setup.py
index 1cd1503..f8af141 100644
--- a/setup.py
+++ b/setup.py
@@ -39,6 +39,17 @@ def get_platform():
     return sys.platform
 host_platform = get_platform()
 
+# On MSYS, os.system needs to be wrapped with sh.exe
+# as otherwise all the io redirection will fail.
+# Arguably, this could happen inside the real os.system
+# rather than this monkey patch.
+if sys.platform == "win32" and "MSYSTEM" in os.environ:
+    os_system = os.system
+    def msys_system(command):
+        command_in_sh = 'sh.exe -c "%s"' % command.replace("\\", "\\\\")
+        return os_system(command_in_sh)
+    os.system = msys_system
+
 # Were we compiled --with-pydebug or with #define Py_DEBUG?
 COMPILED_WITH_PYDEBUG = ('--with-pydebug' in sysconfig.get_config_var("CONFIG_ARGS"))
 
@@ -199,6 +210,9 @@ class PyBuildExt(build_ext):
 
     def build_extensions(self):
 
+        if host_platform.startswith(('mingw', 'win', 'cygwin')):
+            self.compiler.define_macro("Py_BUILD_CORE_MODULE")
+
         # Detect which modules should be compiled
         missing = self.detect_modules()
 
@@ -405,7 +419,7 @@ class PyBuildExt(build_ext):
         # Debian/Ubuntu multiarch support.
         # https://wiki.ubuntu.com/MultiarchSpec
         cc = sysconfig.get_config_var('CC')
-        tmpfile = os.path.join(self.build_temp, 'multiarch')
+        tmpfile = os.path.join(self.build_temp, 'multiarch').replace('\\','/')
         if not os.path.exists(self.build_temp):
             os.makedirs(self.build_temp)
         ret = os.system(
@@ -430,7 +444,7 @@ class PyBuildExt(build_ext):
         opt = ''
         if cross_compiling:
             opt = '-t' + sysconfig.get_config_var('HOST_GNU_TYPE')
-        tmpfile = os.path.join(self.build_temp, 'multiarch')
+        tmpfile = os.path.join(self.build_temp, 'multiarch').replace('\\','/')
         if not os.path.exists(self.build_temp):
             os.makedirs(self.build_temp)
         ret = os.system(
@@ -449,7 +463,7 @@ class PyBuildExt(build_ext):
 
     def add_gcc_paths(self):
         gcc = sysconfig.get_config_var('CC')
-        tmpfile = os.path.join(self.build_temp, 'gccpaths')
+        tmpfile = os.path.join(self.build_temp, 'gccpaths').replace('\\','/')
         if not os.path.exists(self.build_temp):
             os.makedirs(self.build_temp)
         ret = os.system('%s -E -v - </dev/null 2>%s 1>/dev/null' % (gcc, tmpfile))
@@ -493,10 +507,10 @@ class PyBuildExt(build_ext):
         if not cross_compiling:
             add_dir_to_list(self.compiler.library_dirs, '/usr/local/lib')
             add_dir_to_list(self.compiler.include_dirs, '/usr/local/include')
+            self.add_multiarch_paths()
         # only change this for cross builds for 3.3, issues on Mageia
         if cross_compiling:
             self.add_gcc_paths()
-        self.add_multiarch_paths()
 
         # Add paths specified in the environment variables LDFLAGS and
         # CPPFLAGS for header and library files.
@@ -573,7 +587,7 @@ class PyBuildExt(build_ext):
         if host_platform == 'hp-ux11':
             lib_dirs += ['/usr/lib/hpux64', '/usr/lib/hpux32']
 
-        if host_platform == 'darwin':
+        if host_platform in ['darwin', 'mingw', 'win32']:
             # This should work on any unixy platform ;-)
             # If the user has bothered specifying additional -I and -L flags
             # in OPT and LDFLAGS we might as well use them here.
@@ -583,6 +597,8 @@ class PyBuildExt(build_ext):
             # directories with whitespace in the name to store libraries.
             cflags, ldflags = sysconfig.get_config_vars(
                     'CFLAGS', 'LDFLAGS')
+            cflags = cflags + ' ' + ('',os.environ.get('CC'))[os.environ.get('CC') != None]
+            ldflags = ldflags + ' ' + ('',os.environ.get('LDSHARED'))[os.environ.get('LDSHARED') != None]
             for item in cflags.split():
                 if item.startswith('-I'):
                     inc_dirs.append(item[2:])
@@ -668,11 +684,20 @@ class PyBuildExt(build_ext):
         if (config_h_vars.get('FLOCK_NEEDS_LIBBSD', False)):
             # May be necessary on AIX for flock function
             libs = ['bsd']
-        exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
+        if not host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
+        else:
+            missing.append('fcntl')
         # pwd(3)
-        exts.append( Extension('pwd', ['pwdmodule.c']) )
+        if not host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('pwd', ['pwdmodule.c']) )
+        else:
+            missing.append('pwd')
         # grp(3)
-        exts.append( Extension('grp', ['grpmodule.c']) )
+        if not host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('grp', ['grpmodule.c']) )
+        else:
+            missing.append('grp')
         # spwd, shadow passwords
         if (config_h_vars.get('HAVE_GETSPNAM', False) or
                 config_h_vars.get('HAVE_GETSPENT', False)):
@@ -681,7 +706,11 @@ class PyBuildExt(build_ext):
             missing.append('spwd')
 
         # select(2); not on ancient System V
-        exts.append( Extension('select', ['selectmodule.c']) )
+        select_libs = []
+        if host_platform.startswith(('mingw', 'win')):
+            select_libs += ['ws2_32']
+        exts.append( Extension('select', ['selectmodule.c'],
+                               libraries=select_libs) )
 
         # Fred Drake's interface to the Python parser
         exts.append( Extension('parser', ['parsermodule.c']) )
@@ -691,7 +720,10 @@ class PyBuildExt(build_ext):
 
         # Lance Ellinghaus's syslog module
         # syslog daemon interface
-        exts.append( Extension('syslog', ['syslogmodule.c']) )
+        if not host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('syslog', ['syslogmodule.c']) )
+        else:
+            missing.append('syslog')
 
         #
         # Here ends the simple stuff.  From here on, modules need certain
@@ -715,7 +747,7 @@ class PyBuildExt(build_ext):
         readline_termcap_library = ""
         curses_library = ""
         # Cannot use os.popen here in py3k.
-        tmpfile = os.path.join(self.build_temp, 'readline_termcap_lib')
+        tmpfile = os.path.join(self.build_temp, 'readline_termcap_lib').replace('\\','/')
         if not os.path.exists(self.build_temp):
             os.makedirs(self.build_temp)
         # Determine if readline is already linked against curses or tinfo.
@@ -786,29 +818,40 @@ class PyBuildExt(build_ext):
                                                      ['/usr/lib/termcap'],
                                                      'termcap'):
                 readline_libs.append('termcap')
-            exts.append( Extension('readline', ['readline.c'],
+            exts.append( Extension('readline', ['readline.c', '../Python/iscygpty.c'],
                                    library_dirs=['/usr/lib/termcap'],
                                    extra_link_args=readline_extra_link_args,
-                                   libraries=readline_libs) )
+                                   libraries=readline_libs,
+                                   extra_compile_args=["-D_WIN32_WINNT=0x0600"]) )
         else:
             missing.append('readline')
 
         # crypt module.
 
-        if self.compiler.find_library_file(lib_dirs, 'crypt'):
-            libs = ['crypt']
+        if not host_platform.startswith(('mingw', 'win')):
+            if self.compiler.find_library_file(lib_dirs, 'crypt'):
+                libs = ['crypt']
+            else:
+                libs = []
+            exts.append( Extension('_crypt', ['_cryptmodule.c'], libraries=libs) )
         else:
-            libs = []
-        exts.append( Extension('_crypt', ['_cryptmodule.c'], libraries=libs) )
+            missing.append('_crypt')
 
         # CSV files
         exts.append( Extension('_csv', ['_csv.c']) )
 
         # POSIX subprocess module helper.
-        exts.append( Extension('_posixsubprocess', ['_posixsubprocess.c']) )
+        if not host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('_posixsubprocess', ['_posixsubprocess.c']) )
+        else:
+            missing.append('_posixsubprocess')
 
         # socket(2)
+        socket_libs = []
+        if host_platform.startswith(('mingw', 'win')):
+            socket_libs += ['ws2_32']
         exts.append( Extension('_socket', ['socketmodule.c'],
+                               libraries = socket_libs,
                                depends = ['socketmodule.h']) )
         # Detect SSL support for the socket module (via _ssl)
         search_for_ssl_incs_in = [
@@ -830,10 +873,13 @@ class PyBuildExt(build_ext):
 
         if (ssl_incs is not None and
             ssl_libs is not None):
+            _ssl_libs = ['ssl', 'crypto']
+            if host_platform.startswith(('mingw', 'win')):
+                _ssl_libs += ['ws2_32']
             exts.append( Extension('_ssl', ['_ssl.c'],
                                    include_dirs = ssl_incs,
                                    library_dirs = ssl_libs,
-                                   libraries = ['ssl', 'crypto'],
+                                   libraries = _ssl_libs,
                                    depends = ['socketmodule.h']), )
         else:
             missing.append('_ssl')
@@ -847,7 +893,7 @@ class PyBuildExt(build_ext):
         opensslv_h = find_file('openssl/opensslv.h', [],
                 inc_dirs + search_for_ssl_incs_in)
         if opensslv_h:
-            name = os.path.join(opensslv_h[0], 'openssl/opensslv.h')
+            name = os.path.join(opensslv_h[0], 'openssl/opensslv.h').replace('\\','/')
             if host_platform == 'darwin' and is_macosx_sdk_path(name):
                 name = os.path.join(macosx_sdk_root(), name[1:])
             try:
@@ -898,6 +944,7 @@ class PyBuildExt(build_ext):
 
         blake2_macros = []
         if (not cross_compiling and
+                not host_platform.startswith(('mingw', 'win')) and
                 os.uname().machine == "x86_64" and
                 sys.maxsize >  2**32):
             # Every x86_64 machine has at least SSE2.  Check for sys.maxsize
@@ -937,6 +984,26 @@ class PyBuildExt(build_ext):
         min_db_ver = (3, 3)
         db_setup_debug = False   # verbose debug prints from this script?
 
+        # Modules with some Windows dependencies:
+        if host_platform.startswith(('mingw', 'win')):
+            srcdir = sysconfig.get_config_var('srcdir')
+            pc_srcdir = os.path.abspath(os.path.join(srcdir, 'PC'))
+
+            exts.append( Extension('msvcrt', [os.path.join(pc_srcdir, p)
+                for p in ['msvcrtmodule.c']]) )
+
+            # Added to Setup.config.in as now needed earlier since I
+            # use subprocess (which uses Popen) in cygwinccompiler.py
+            # exts.append( Extension('_winapi', ['_winapi.c']) )
+
+            exts.append( Extension('_msi', [os.path.join(pc_srcdir, p)
+                for p in ['_msi.c']],
+                libraries=['msi','cabinet','rpcrt4']) ) # To link with lib(msi|cabinet|rpcrt4).a
+
+            exts.append( Extension('winsound', [os.path.join(pc_srcdir, p)
+                for p in ['winsound.c']],
+                libraries=['winmm']) )
+
         def allow_db_ver(db_ver):
             """Returns a boolean if the given BerkeleyDB version is acceptable.
 
@@ -1202,11 +1269,7 @@ class PyBuildExt(build_ext):
                 '_sqlite/statement.c',
                 '_sqlite/util.c', ]
 
-            sqlite_defines = []
-            if host_platform != "win32":
-                sqlite_defines.append(('MODULE_NAME', '"sqlite3"'))
-            else:
-                sqlite_defines.append(('MODULE_NAME', '\\"sqlite3\\"'))
+            sqlite_defines = [('MODULE_NAME', '"sqlite3"')]
 
             # Enable support for loadable extensions in the sqlite3 module
             # if --enable-loadable-sqlite-extensions configure option is used.
@@ -1252,7 +1315,7 @@ class PyBuildExt(build_ext):
             if dbm_args:
                 dbm_order = [arg.split('=')[-1] for arg in dbm_args][-1].split(":")
             else:
-                dbm_order = "ndbm:gdbm:bdb".split(":")
+                dbm_order = []
             dbmext = None
             for cand in dbm_order:
                 if cand == "ndbm":
@@ -1326,7 +1389,7 @@ class PyBuildExt(build_ext):
             missing.append('_gdbm')
 
         # Unix-only modules
-        if host_platform != 'win32':
+        if not host_platform.startswith(('mingw', 'win')):
             # Steen Lumholt's termios module
             exts.append( Extension('termios', ['termios.c']) )
             # Jeremy Hylton's rlimit interface
@@ -1592,7 +1655,7 @@ class PyBuildExt(build_ext):
             macros = dict()
             libraries = ['rt']
 
-        if host_platform == 'win32':
+        if host_platform.startswith(('mingw', 'win')):
             multiprocessing_srcs = [ '_multiprocessing/multiprocessing.c',
                                      '_multiprocessing/semaphore.c',
                                    ]
@@ -1605,8 +1668,12 @@ class PyBuildExt(build_ext):
                 multiprocessing_srcs.append('_multiprocessing/semaphore.c')
 
         if sysconfig.get_config_var('WITH_THREAD'):
+            multiprocessing_libs = []
+            if host_platform.startswith(('mingw', 'win')):
+                multiprocessing_libs += ['ws2_32']
             exts.append ( Extension('_multiprocessing', multiprocessing_srcs,
                                     define_macros=list(macros.items()),
+                                    libraries=multiprocessing_libs,
                                     include_dirs=["Modules/_multiprocessing"]))
         else:
             missing.append('_multiprocessing')
@@ -1626,6 +1693,10 @@ class PyBuildExt(build_ext):
                            '-framework', 'CoreFoundation',
                         ]))
 
+        if host_platform.startswith(('mingw', 'win')):
+            exts.append( Extension('_overlapped', ['overlapped.c'],
+                                   libraries=['ws2_32']))
+
         self.extensions.extend(exts)
 
         # Call the method for detecting whether _tkinter can be compiled
@@ -1736,16 +1807,16 @@ class PyBuildExt(build_ext):
         cflags = sysconfig.get_config_vars('CFLAGS')[0]
         archs = re.findall(r'-arch\s+(\w+)', cflags)
 
-        tmpfile = os.path.join(self.build_temp, 'tk.arch')
+        tmpfile = os.path.join(self.build_temp, 'tk.arch').replace('\\','/')
         if not os.path.exists(self.build_temp):
             os.makedirs(self.build_temp)
 
         # Note: cannot use os.popen or subprocess here, that
         # requires extensions that are not available here.
         if is_macosx_sdk_path(F):
-            os.system("file %s/Tk.framework/Tk | grep 'for architecture' > %s"%(os.path.join(sysroot, F[1:]), tmpfile))
+            os.system("file %s/Tk.framework/Tk | grep 'for architecture' > %s"%(os.path.join(sysroot, F[1:]).replace('\\','/'), tmpfile))
         else:
-            os.system("file %s/Tk.framework/Tk | grep 'for architecture' > %s"%(F, tmpfile))
+            os.system("file %s/Tk.framework/Tk | grep 'for architecture' > %s"%(F.replace('\\','/'), tmpfile))
 
         with open(tmpfile) as fp:
             detected_archs = []
@@ -1790,14 +1861,19 @@ class PyBuildExt(build_ext):
         # The versions with dots are used on Unix, and the versions without
         # dots on Windows, for detection by cygwin.
         tcllib = tklib = tcl_includes = tk_includes = None
-        for version in ['8.6', '86', '8.5', '85', '8.4', '84', '8.3', '83',
-                        '8.2', '82', '8.1', '81', '8.0', '80']:
-            tklib = self.compiler.find_library_file(lib_dirs,
-                                                        'tk' + version)
-            tcllib = self.compiler.find_library_file(lib_dirs,
-                                                         'tcl' + version)
-            if tklib and tcllib:
-                # Exit the loop when we've found the Tcl/Tk libraries
+        tcltk_suffix = None
+        for suffix in ['', 's']:
+            for version in ['8.6', '86', '8.5', '85', '8.4', '84', '8.3', '83',
+                            '8.2', '82', '8.1', '81', '8.0', '80', '']:
+                tklib = self.compiler.find_library_file(lib_dirs,
+                                                            'tk' + version + suffix)
+                tcllib = self.compiler.find_library_file(lib_dirs,
+                                                             'tcl' + version + suffix)
+                if tklib and tcllib:
+                    # Exit the loop when we've found the Tcl/Tk libraries
+                    tcltk_suffix = suffix
+                    break
+            if tcltk_suffix != None:
                 break
 
         # Now check for the header files
@@ -1865,13 +1941,21 @@ class PyBuildExt(build_ext):
         # Add the Tcl/Tk libraries
         libs.append('tk'+ version)
         libs.append('tcl'+ version)
+        libs.append('tk'+ version + tcltk_suffix)
+        libs.append('tcl'+ version + tcltk_suffix)
+        if host_platform in ['mingw', 'win32']:
+            for winlib in ['ws2_32','gdi32','comctl32','comdlg32','imm32','uuid','oleaut32','ole32']:
+                libs.append( winlib )
 
         if host_platform in ['aix3', 'aix4']:
             libs.append('ld')
 
         # Finally, link with the X11 libraries (not appropriate on cygwin)
-        if host_platform != "cygwin":
+        # ...on those platforms, define STATIC_BUILD if linking to static tcl/tk.
+        if not host_platform in ['cygwin', 'mingw', 'win32']:
             libs.append('X11')
+        elif tcllib.endswith('s.a'):
+            defs.append( ('STATIC_BUILD',1) )
 
         ext = Extension('_tkinter', ['_tkinter.c', 'tkappinit.c'],
                         define_macros=[('WITH_APPINIT', 1)] + defs,
@@ -1917,6 +2001,10 @@ class PyBuildExt(build_ext):
         return True
 
     def configure_ctypes(self, ext):
+        if host_platform == 'win32':
+            ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
+            ext.export_symbols.extend(['DllGetClassObject PRIVATE',
+                                       'DllCanUnloadNow PRIVATE'])
         if not self.use_system_libffi:
             if host_platform == 'darwin':
                 return self.configure_ctypes_darwin(ext)
@@ -1944,6 +2032,10 @@ class PyBuildExt(build_ext):
                 if not self.verbose:
                     config_args.append("-q")
 
+                if host_platform == 'win32':
+                    table = str.maketrans('\\', '/')
+                    ffi_builddir = ffi_builddir.translate(table)
+                    ffi_srcdir = ffi_srcdir.translate(table)
                 # Pass empty CFLAGS because we'll just append the resulting
                 # CFLAGS to Python's; -g or -O2 is to be avoided.
                 cmd = "cd %s && env CFLAGS='' '%s/configure' %s" \
@@ -2018,6 +2110,8 @@ class PyBuildExt(build_ext):
         ext_test = Extension('_ctypes_test',
                      sources=['_ctypes/_ctypes_test.c'],
                      libraries=math_libs)
+        if host_platform.startswith(('mingw', 'win')):
+            ext_test.libraries.extend(['oleaut32'])
         self.extensions.extend([ext, ext_test])
 
         if host_platform == 'darwin':
@@ -2054,6 +2148,8 @@ class PyBuildExt(build_ext):
         if ffi_inc and ffi_lib:
             ext.include_dirs.extend(ffi_inc)
             ext.libraries.append(ffi_lib)
+            if host_platform.startswith(('mingw', 'win')):
+                ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
             self.use_system_libffi = True
 
     def _decimal_ext(self):
@@ -2244,7 +2340,7 @@ class PyBuildScripts(build_scripts):
             else:
                 newfilename = filename + minoronly
             log.info('renaming %s to %s', filename, newfilename)
-            os.rename(filename, newfilename)
+            os.replace(filename, newfilename)
             newoutfiles.append(newfilename)
             if filename in updated_files:
                 newupdated_files.append(newfilename)
-- 
2.14.2

